<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TikTokApi.tiktok API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TikTokApi.tiktok</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import requests
import time
import logging
import json
from urllib.parse import urlencode, quote
from playwright.sync_api import sync_playwright
import string
import logging
import os
from .utilities import update_messager
from .exceptions import *


os.environ[&#34;no_proxy&#34;] = &#34;127.0.0.1,localhost&#34;

BASE_URL = &#34;https://m.tiktok.com/&#34;


class TikTokApi:
    __instance = None

    def __init__(self, **kwargs):
        &#34;&#34;&#34;The TikTokApi class. Used to interact with TikTok, use get_instance NOT this.&#34;&#34;&#34;
        # Forces Singleton
        if TikTokApi.__instance is None:
            TikTokApi.__instance = self
        else:
            raise Exception(&#34;Only one TikTokApi object is allowed&#34;)
        logging.basicConfig(level=kwargs.get(&#34;logging_level&#34;, logging.WARNING))
        logging.info(&#34;Class initalized&#34;)

        # Some Instance Vars
        self.executablePath = kwargs.get(&#34;executablePath&#34;, None)
        self.custom_did = kwargs.get(&#34;custom_did&#34;, None)
        self.userAgent = (
            &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &#34;
            &#34;AppleWebKit/537.36 (KHTML, like Gecko) &#34;
            &#34;Chrome/86.0.4240.111 Safari/537.36&#34;
        )
        self.proxy = kwargs.get(&#34;proxy&#34;, None)
        self.custom_verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)
        self.signer_url = kwargs.get(&#34;external_signer&#34;, None)
        self.request_delay = kwargs.get(&#34;request_delay&#34;, None)

        if kwargs.get(&#34;use_test_endpoints&#34;, False):
            global BASE_URL
            BASE_URL = &#34;https://t.tiktok.com/&#34;
        if kwargs.get(&#34;use_selenium&#34;, False):
            from .browser_selenium import browser
        else:
            from .browser import browser

        if kwargs.get(&#34;generate_static_did&#34;, False):
            self.custom_did = &#34;&#34;.join(random.choice(string.digits) for num in range(19))

        if self.signer_url is None:
            self.browser = browser(**kwargs)
            self.userAgent = self.browser.userAgent

        try:
            self.timezone_name = self.__format_new_params__(self.browser.timezone_name)
            self.browser_language = self.__format_new_params__(
                self.browser.browser_language
            )
            self.browser_platform = self.__format_new_params__(
                self.browser.browser_platform
            )
            self.browser_name = self.__format_new_params__(self.browser.browser_name)
            self.browser_version = self.__format_new_params__(
                self.browser.browser_version
            )
            self.width = self.browser.width
            self.height = self.browser.height
        except Exception as e:
            logging.error(e)
            logging.warning(
                &#34;An error ocurred while opening your browser but it was ignored.&#34;
            )

            self.timezone_name = &#34;&#34;
            self.browser_language = &#34;&#34;
            self.browser_platform = &#34;&#34;
            self.browser_name = &#34;&#34;
            self.browser_version = &#34;&#34;
            self.width = &#34;1920&#34;
            self.height = &#34;1080&#34;

    @staticmethod
    def get_instance(**kwargs):
        &#34;&#34;&#34;The TikTokApi class. Used to interact with TikTok. This is a singleton
            class to prevent issues from arising with playwright

        Parameters
        ----------
        logging_level: The logging level you want the program to run at, optional
            These are the standard python logging module&#39;s levels.
        request_delay: The amount of time to wait before making a request, optional
            This is used to throttle your own requests as you may end up making too
            many requests to TikTok for your IP.
        custom_did: A TikTok parameter needed to download videos, optional
            The code generates these and handles these pretty well itself, however
            for some things such as video download you will need to set a consistent
            one of these.

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.
        generate_static_did: A parameter that generates a custom_did at the instance level
            Use this if you want to download videos from a script but don&#39;t want to generate
            your own custom_did parameter.
        custom_verifyFp: A TikTok parameter needed to work most of the time, optional
            To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
            I recommend watching the entire thing, as it will help setup this package.

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.

            You can use the following to generate `&#34;&#34;.join(random.choice(string.digits)
            for num in range(19))`
        use_test_endpoints: Send requests to TikTok&#39;s test endpoints, optional
            This parameter when set to true will make requests to TikTok&#39;s testing
            endpoints instead of the live site. I can&#39;t guarantee this will work
            in the future, however currently basically any custom_verifyFp will
            work here which is helpful.
        proxy: A string containing your proxy address, optional
            If you want to do a lot of scraping of TikTok endpoints you&#39;ll likely
            need a proxy.

            Ex: &#34;https://0.0.0.0:8080&#34;

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.
        use_selenium: Option to use selenium over playwright, optional
            Playwright is selected by default and is the one that I&#39;m designing the
            package to be compatable for, however if playwright doesn&#39;t work on
            your machine feel free to set this to True.
        executablePath: The location of the driver, optional
            This shouldn&#39;t be needed if you&#39;re using playwright
        **kwargs
            Parameters that are passed on to basically every module and methods
            that interact with this main class. These may or may not be documented
            in other places.
        &#34;&#34;&#34;
        if not TikTokApi.__instance:
            TikTokApi(**kwargs)
        return TikTokApi.__instance

    def clean_up(self):
        &#34;&#34;&#34;A basic cleanup method, called automatically from the code&#34;&#34;&#34;
        self.__del__()

    def __del__(self):
        &#34;&#34;&#34;A basic cleanup method, called automatically from the code&#34;&#34;&#34;
        try:
            self.browser.clean_up()
        except Exception:
            pass
        try:
            get_playwright().stop()
        except Exception:
            pass
        TikTokApi.__instance = None

    def external_signer(self, url, custom_did=None, verifyFp=None):
        &#34;&#34;&#34;Makes requests to an external signer instead of using a browser.

        Parameters
        ----------
        url: The server to make requests to
            This server is designed to sign requests. You can find an example
            of this signature server in the examples folder.
        custom_did: A TikTok parameter needed to download videos
            The code generates these and handles these pretty well itself, however
            for some things such as video download you will need to set a consistent
            one of these.
        custom_verifyFp: A TikTok parameter needed to work most of the time,
            To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
            I recommend watching the entire thing, as it will help setup this package.
        &#34;&#34;&#34;
        if custom_did is not None:
            query = {&#34;url&#34;: url, &#34;custom_did&#34;: custom_did, &#34;verifyFp&#34;: verifyFp}
        else:
            query = {&#34;url&#34;: url, &#34;verifyFp&#34;: verifyFp}
        data = requests.get(self.signer_url + &#34;?{}&#34;.format(urlencode(query)))
        parsed_data = data.json()

        return (
            parsed_data[&#34;verifyFp&#34;],
            parsed_data[&#34;did&#34;],
            parsed_data[&#34;_signature&#34;],
            parsed_data[&#34;userAgent&#34;],
            parsed_data[&#34;referrer&#34;],
        )

    def get_data(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Makes requests to TikTok and returns their JSON.

        This is all handled by the package so it&#39;s unlikely
        you will need to use this.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        if self.request_delay is not None:
            time.sleep(self.request_delay)

        if self.proxy is not None:
            proxy = self.proxy

        if kwargs.get(&#34;custom_verifyFp&#34;) == None:
            if self.custom_verifyFp != None:
                verifyFp = self.custom_verifyFp
            else:
                verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
        else:
            verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

        if self.signer_url is None:
            kwargs[&#34;custom_verifyFp&#34;] = verifyFp
            verify_fp, did, signature = self.browser.sign_url(**kwargs)
            userAgent = self.browser.userAgent
            referrer = self.browser.referrer
        else:
            verify_fp, did, signature, userAgent, referrer = self.external_signer(
                kwargs[&#34;url&#34;],
                custom_did=kwargs.get(&#34;custom_did&#34;),
                verifyFp=kwargs.get(&#34;custom_verifyFp&#34;, verifyFp),
            )

        query = {&#34;verifyFp&#34;: verify_fp, &#34;did&#34;: did, &#34;_signature&#34;: signature}
        url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
        r = requests.get(
            url,
            headers={
                &#34;authority&#34;: &#34;m.tiktok.com&#34;,
                &#34;method&#34;: &#34;GET&#34;,
                &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
                &#34;scheme&#34;: &#34;https&#34;,
                &#34;accept&#34;: &#34;application/json, text/plain, */*&#34;,
                &#34;accept-encoding&#34;: &#34;gzip, deflate, br&#34;,
                &#34;accept-language&#34;: &#34;en-US,en;q=0.9&#34;,
                &#34;cache-control&#34;: &#34;no-cache&#34;,
                &#34;dnt&#34;: &#34;1&#34;,
                &#34;origin&#34;: referrer,
                &#34;pragma&#34;: &#34;no-cache&#34;,
                &#34;referer&#34;: referrer,
                &#34;sec-fetch-dest&#34;: &#34;empty&#34;,
                &#34;sec-fetch-mode&#34;: &#34;cors&#34;,
                &#34;sec-fetch-site&#34;: &#34;same-site&#34;,
                &#34;user-agent&#34;: userAgent,
            },
            cookies=self.get_cookies(**kwargs),
            proxies=self.__format_proxy(proxy),
        )
        try:
            json = r.json()
            if json.get(&#34;type&#34;) == &#34;verify&#34;:
                logging.error(
                    &#34;Tiktok wants to display a catcha. Response is:\n&#34; + r.text
                )
                logging.error(self.get_cookies(**kwargs))
                raise TikTokCaptchaError()
            if json.get(&#34;statusCode&#34;, 200) == 10201:
                # Invalid Entity
                raise TikTokNotFoundError(
                    &#34;TikTok returned a response indicating the entity is invalid&#34;
                )
            return r.json()
        except ValueError as e:
            text = r.text
            logging.error(&#34;TikTok response: &#34; + text)
            if len(text) == 0:
                raise EmptyResponseError(
                    &#34;Empty response from Tiktok to &#34; + url
                ) from None
            else:
                logging.error(&#34;Converting response to JSON failed&#34;)
                logging.error(e)
                raise JSONDecodeFailure() from e

    def get_cookies(self, **kwargs):
        &#34;&#34;&#34;Extracts cookies from the kwargs passed to the function for get_data&#34;&#34;&#34;
        did = kwargs.get(
            &#34;custom_did&#34;, &#34;&#34;.join(random.choice(string.digits) for num in range(19))
        )
        if kwargs.get(&#34;custom_verifyFp&#34;) == None:
            if self.custom_verifyFp != None:
                verifyFp = self.custom_verifyFp
            else:
                verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
        else:
            verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

        if kwargs.get(&#34;force_verify_fp_on_cookie_header&#34;, False):
            return {
                &#34;tt_webid&#34;: did,
                &#34;tt_webid_v2&#34;: did,
                &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                    random.choice(string.ascii_uppercase + string.ascii_lowercase)
                    for i in range(16)
                ),
                &#34;s_v_web_id&#34;: verifyFp,
            }
        else:
            return {
                &#34;tt_webid&#34;: did,
                &#34;tt_webid_v2&#34;: did,
                &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                    random.choice(string.ascii_uppercase + string.ascii_lowercase)
                    for i in range(16)
                ),
            }

    def get_bytes(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Returns TikTok&#39;s response as bytes, similar to get_data&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        if self.signer_url is None:
            verify_fp, did, signature = self.browser.sign_url(**kwargs)
            userAgent = self.browser.userAgent
            referrer = self.browser.referrer
        else:
            verify_fp, did, signature, userAgent, referrer = self.external_signer(
                kwargs[&#34;url&#34;], custom_did=kwargs.get(&#34;custom_did&#34;, None)
            )
        query = {&#34;verifyFp&#34;: verify_fp, &#34;_signature&#34;: signature}
        url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
        r = requests.get(
            url,
            headers={
                &#34;Accept&#34;: &#34;*/*&#34;,
                &#34;Accept-Encoding&#34;: &#34;identity;q=1, *;q=0&#34;,
                &#34;Accept-Language&#34;: &#34;en-US;en;q=0.9&#34;,
                &#34;Cache-Control&#34;: &#34;no-cache&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: url.split(&#34;/&#34;)[2],
                &#34;Pragma&#34;: &#34;no-cache&#34;,
                &#34;Range&#34;: &#34;bytes=0-&#34;,
                &#34;Referer&#34;: &#34;https://www.tiktok.com/&#34;,
                &#34;User-Agent&#34;: userAgent,
            },
            proxies=self.__format_proxy(proxy),
            cookies=self.get_cookies(**kwargs),
        )
        return r.content

    def by_trending(self, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;
        Gets trending TikToks

        Parameters
        ----------
        count: The amount of TikToks you want returned, optional
            Note: TikTok seems to only support at MOST ~2000 TikToks
            from a single endpoint.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: 1,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;sourceType&#34;: 12,
                &#34;appId&#34;: 1233,
                &#34;itemID&#34;: 1,
                &#34;insertedItemID&#34;: &#34;&#34;,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )
            res = self.getData(url=api_url, **kwargs)
            for t in res.get(&#34;itemList&#34;, []):
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response[:count]

            realCount = count - len(response)

            first = False

        return response[:count]

    def search_for_users(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of users that match the search_term

        Parameters
        ----------
        search_term: The string to search for users by
            This string is the term you want to search for users by.
        count: The number of users to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(search_term, prefix=&#34;user&#34;, count=count, **kwargs)

    def search_for_music(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of music that match the search_term

        Parameters
        ----------
        search_term: The string to search for music by
            This string is the term you want to search for music by.
        count: The number of music to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(search_term, prefix=&#34;music&#34;, count=count, **kwargs)

    def search_for_hashtags(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of hashtags that match the search_term

        Parameters
        ----------
        search_term: The string to search for music by
            This string is the term you want to search for music by.
        count: The number of music to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(
            search_term, prefix=&#34;challenge&#34;, count=count, **kwargs
        )

    def discover_type(self, search_term, prefix, count=28, offset=0, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of whatever the prefix type you pass in

        Parameters
        ----------
        search_term: The string to search by
            This string is the term you want to search by.
        prefix: The prefix of what to search for
            Valid options are user/music/challenge
        count: The number search results to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        while len(response) &lt; count:
            query = {
                &#34;discoverType&#34;: count,
                &#34;needItemList&#34;: False,
                &#34;keyWord&#34;: search_term,
                &#34;offset&#34;: offset,
                &#34;count&#34;: 99,
                &#34;useRecommend&#34;: False,
                &#34;language&#34;: &#34;en&#34;,
            }
            api_url = &#34;{}api/discover/{}/?{}&amp;{}&#34;.format(
                BASE_URL, prefix, self.__add_new_params__(), urlencode(query)
            )
            data = self.getData(url=api_url, **kwargs)

            if &#34;userInfoList&#34; in data.keys():
                for x in data[&#34;userInfoList&#34;]:
                    response.append(x)
            elif &#34;musicInfoList&#34; in data.keys():
                for x in data[&#34;musicInfoList&#34;]:
                    response.append(x)
            elif &#34;challengeInfoList&#34; in data.keys():
                for x in data[&#34;challengeInfoList&#34;]:
                    response.append(x)
            else:
                logging.info(&#34;TikTok is not sending videos beyond this point.&#34;)
                break

            offset += maxCount

        return response[:count]

    def user_posts(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns an array of dictionaries representing TikToks for a user.

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        secUID: The secUID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: userID,
                &#34;cursor&#34;: cursor,
                &#34;type&#34;: 1,
                &#34;secUid&#34;: secUID,
                &#34;sourceType&#34;: 8,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/post/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            if &#34;itemList&#34; in res.keys():
                for t in res[&#34;itemList&#34;]:
                    response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            cursor = res[&#34;cursor&#34;]

            first = False

        return response[:count]

    def by_username(self, username, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks given a user&#39;s username.

        Parameters
        ----------
        username: The username of the TikTok user
            This is just the username of the user you want to
            get videos from.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)
        return self.userPosts(
            data[&#34;id&#34;],
            data[&#34;secUid&#34;],
            count=count,
            **kwargs,
        )

    def user_page(self, userID, secUID, page_size=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing of one page of TikToks given a user&#39;s ID and secUID

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        secUID: The secUID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        page_size: The number of posts to return per page
            Gets a specific page of a user, doesn&#39;t iterate.
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        api_url = (
            BASE_URL + &#34;api/post/item_list/?{}&amp;count={}&amp;id={}&amp;type=1&amp;secUid={}&#34;
            &#34;&amp;cursor={}&amp;sourceType=8&amp;appId=1233&amp;region={}&amp;language={}&#34;.format(
                self.__add_new_params__(),
                page_size,
                str(userID),
                str(secUID),
                cursor,
                region,
                language,
            )
        )

        return self.getData(url=api_url, **kwargs)

    def get_user_pager(self, username, page_size=30, cursor=0, **kwargs):
        &#34;&#34;&#34;Returns a generator to page through a user&#39;s feed

        Parameters
        ----------
        username: The username of the user
        page_size: The number of posts to return in a page
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)

        while True:
            resp = self.userPage(
                data[&#34;id&#34;],
                data[&#34;secUid&#34;],
                page_size=page_size,
                cursor=cursor,
                **kwargs,
            )

            try:
                page = resp[&#34;itemList&#34;]
            except KeyError:
                # No mo results
                return

            cursor = resp[&#34;cursor&#34;]

            yield page

            if not resp[&#34;hasMore&#34;]:
                return  # all done

    def user_liked(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks that a given a user has liked.
           Note: The user&#39;s likes must be public

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
        secUID: The secUID of the user, which TikTok assigns
        count: The number of posts to return
                      Note: seems to only support up to ~2,000
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: userID,
                &#34;type&#34;: 2,
                &#34;secUid&#34;: secUID,
                &#34;cursor&#34;: cursor,
                &#34;sourceType&#34;: 9,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/favorite/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            try:
                res[&#34;itemList&#34;]
            except Exception:
                logging.error(&#34;User&#39;s likes are most likely private&#34;)
                return []

            for t in res[&#34;itemList&#34;]:
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            cursor = res[&#34;cursor&#34;]

            first = False

        return response[:count]

    def user_liked_by_username(self, username, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks a user has liked by username.
           Note: The user&#39;s likes must be public

        Parameters
        ----------
        username: The username of the user
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)
        return self.userLiked(
            data[&#34;id&#34;],
            data[&#34;secUid&#34;],
            count=count,
            **kwargs,
        )

    def by_sound(self, id, count=30, offset=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific sound.

        Parameters
        ----------
        id: The sound id to search by
            Note: Can be found in the URL of the sound specific page or with other methods.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        response = []

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;secUid&#34;: &#34;&#34;,
                &#34;musicID&#34;: str(id),
                &#34;count&#34;: str(realCount),
                &#34;cursor&#34;: offset,
                &#34;shareUid&#34;: &#34;&#34;,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/music/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            try:
                for t in res[&#34;items&#34;]:
                    response.append(t)
            except KeyError:
                for t in res[&#34;itemList&#34;]:
                    response.append(t)

            if not res[&#34;hasMore&#34;]:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            offset = res[&#34;cursor&#34;]

        return response[:count]

    def get_music_object(self, id, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a music object for a specific sound id.

        Parameters
        ----------
        id: The sound id to get the object for
            This can be found by using other methods.
        &#34;&#34;&#34;
        return self.getMusicObjectFull(id, **kwargs)[&#34;music&#34;]

    def get_music_object_full(self, id, **kwargs):
        &#34;&#34;&#34;Returns a music object for a specific sound id.

        Parameters
        ----------
        id: The sound id to get the object for
            This can be found by using other methods.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        r = requests.get(
            &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )
        t = r.text
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        return json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]

    def by_hashtag(self, hashtag, count=30, offset=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific hashtag.

        Parameters
        ----------
        hashtag: The hashtag to search by
            Without the # symbol

            A valid string is &#34;funny&#34;
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        id = self.getHashtagObject(hashtag)[&#34;challengeInfo&#34;][&#34;challenge&#34;][&#34;id&#34;]
        response = []

        required_count = count

        while len(response) &lt; required_count:
            if count &gt; maxCount:
                count = maxCount
            query = {
                &#34;count&#34;: count,
                &#34;challengeID&#34;: id,
                &#34;type&#34;: 3,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;cursor&#34;: offset,
                &#34;priority_region&#34;: &#34;&#34;,
            }
            api_url = &#34;{}api/challenge/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )
            res = self.getData(url=api_url, **kwargs)

            for t in res[&#34;itemList&#34;]:
                response.append(t)

            if not res[&#34;hasMore&#34;]:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            offset += maxCount

        return response[:required_count]

    def get_hashtag_object(self, hashtag, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a hashtag object.

        Parameters
        ----------
        hashtag: The hashtag to search by
            Without the # symbol
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;name&#34;: hashtag, &#34;isName&#34;: True, &#34;lang&#34;: language}
        api_url = &#34;{}node/share/tag/{}?{}&amp;{}&#34;.format(
            BASE_URL, quote(hashtag), self.__add_new_params__(), urlencode(query)
        )
        data = self.getData(url=api_url, **kwargs)
        if data[&#34;challengeInfo&#34;].get(&#34;challenge&#34;) is None:
            raise TikTokNotFoundError(&#34;Challenge {} does not exist&#34;.format(hashtag))
        return data

    def get_recommended_tiktoks_by_video_id(
        self, id, count=30, minCursor=0, maxCursor=0, **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing reccomended TikToks for a specific TikTok video.


        Parameters
        ----------
        id: The id of the video to get suggestions for
            Can be found using other methods
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: 1,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;maxCursor&#34;: maxCursor,
                &#34;minCursor&#34;: minCursor,
                &#34;sourceType&#34;: 12,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            for t in res.get(&#34;items&#34;, []):
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response[:count]

            realCount = count - len(response)
            maxCursor = res[&#34;maxCursor&#34;]

            first = False

        return response[:count]

    def get_tiktok_by_id(self, id, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary of a specific TikTok.

        Parameters
        ----------
        id: The id of the TikTok you want to get the object for
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        did = kwargs.get(&#34;custom_did&#34;, None)
        query = {
            &#34;itemId&#34;: id,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/item/detail/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)

    def get_tiktok_by_url(self, url, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary of a TikTok object by url.


        Parameters
        ----------
        url: The TikTok url you want to retrieve
            This currently doesn&#39;t support the shortened TikTok
            url links.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        custom_did = kwargs.get(&#34;custom_did&#34;, None)
        if &#34;@&#34; in url and &#34;/video/&#34; in url:
            post_id = url.split(&#34;/video/&#34;)[1].split(&#34;?&#34;)[0]
        else:
            raise Exception(
                &#34;URL format not supported. Below is an example of a supported url.\n&#34;
                &#34;https://www.tiktok.com/@therock/video/6829267836783971589&#34;
            )

        return self.getTikTokById(
            post_id,
            **kwargs,
        )

    def get_tiktok_by_html(self, url, **kwargs) -&gt; dict:
        &#34;&#34;&#34;This method retrieves a TikTok using the html
        endpoints rather than the API based ones.

        Parameters
        ----------
        url: The url of the TikTok to get
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)

        r = requests.get(
            url,
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )

        t = r.text
        try:
            j_raw = t.split(
                &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
            )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        except IndexError:
            if not t:
                logging.error(&#34;TikTok response is empty&#34;)
            else:
                logging.error(&#34;TikTok response: \n &#34; + t)
            raise TikTokCaptchaError()

        data = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

        if data[&#34;serverCode&#34;] == 404:
            raise TikTokNotFoundError(
                &#34;TikTok with that url doesn&#39;t exist&#34;.format(username)
            )

        return data

    def discover_hashtags(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Discover page, consists challenges (hashtags)&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]

    def discover_music(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Discover page, consists of music&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]

    def get_user_object(self, username, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Gets a user object (dictionary)

        Parameters
        ----------
        username: The username of the user
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        return self.getUser(username, **kwargs)[&#34;userInfo&#34;][&#34;user&#34;]

    def get_user(self, username, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Gets the full exposed user object

        Parameters
        ----------
        username: The username of the user
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        r = requests.get(
            &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )

        t = r.text

        try:
            j_raw = t.split(
                &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
            )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        except IndexError:
            if not t:
                logging.error(&#34;Tiktok response is empty&#34;)
            else:
                logging.error(&#34;Tiktok response: \n &#34; + t)
            raise TikTokCaptchaError()

        user = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

        if user[&#34;serverCode&#34;] == 404:
            raise TikTokNotFoundError(
                &#34;TikTok user with username {} does not exist&#34;.format(username)
            )

        return user

    def get_suggested_users_by_id(
        self, userId=&#34;6745191554350760966&#34;, count=30, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested users given a different TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        count: The amount of users to return, optional
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][0][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_users_by_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for listing of all user objects it can find.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at, optional
            Optional but uses a static one to start, so you may get more
            unique results with setting your own.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        users = []
        unusedIDS = [startingId]
        while len(users) &lt; count:
            userId = random.choice(unusedIDS)
            newUsers = self.getSuggestedUsersbyID(userId=userId, **kwargs)
            unusedIDS.remove(userId)

            for user in newUsers:
                if user not in users:
                    users.append(user)
                    unusedIDS.append(user[&#34;id&#34;])

        return users[:count]

    def get_suggested_hashtags_by_id(
        self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested hashtags given a TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_hashtags_by_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for as many hashtags as it can find.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        hashtags = []
        ids = self.getSuggestedUsersbyIDCrawler(
            count=count, startingId=startingId, **kwargs
        )
        while len(hashtags) &lt; count and len(ids) != 0:
            userId = random.choice(ids)
            newTags = self.getSuggestedHashtagsbyID(userId=userId[&#34;id&#34;], **kwargs)
            ids.remove(userId)

            for hashtag in newTags:
                if hashtag not in hashtags:
                    hashtags.append(hashtag)

        return hashtags[:count]

    def get_suggested_music_by_id(
        self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested music given a TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        count: The amount of users to return
        proxy: The IP address of a proxy to make requests from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_music_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for hashtags.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        musics = []
        ids = self.getSuggestedUsersbyIDCrawler(
            count=count, startingId=startingId, **kwargs
        )
        while len(musics) &lt; count and len(ids) != 0:
            userId = random.choice(ids)
            newTags = self.getSuggestedMusicbyID(userId=userId[&#34;id&#34;], **kwargs)
            ids.remove(userId)

            for music in newTags:
                if music not in musics:
                    musics.append(music)

        return musics[:count]

    def get_video_by_tiktok(self, data, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads video from TikTok using a TikTok object.

            You will need to set a custom_did to do this for anything but trending.
            To do this, this is pretty simple you can either generate one yourself or,
            you can pass the generate_static_did=True into the constructor of the
            TikTokApi class.

        Parameters
        ----------
        data: A TikTok object
            A TikTok JSON object from any other method.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        try:
            api_url = data[&#34;video&#34;][&#34;downloadAddr&#34;]
        except Exception:
            try:
                api_url = data[&#34;itemInfos&#34;][&#34;video&#34;][&#34;urls&#34;][0]
            except Exception:
                api_url = data[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;playAddr&#34;]
        return self.get_Video_By_DownloadURL(api_url, **kwargs)

    def get_video_by_download_url(self, download_url, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads video from TikTok using download url in a TikTok object

        Parameters
        ----------
        download_url: The download url key value in a TikTok object
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        return self.getBytes(url=download_url, **kwargs)

    def get_video_by_url(self, video_url, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads a TikTok video by a URL

        Parameters
        ----------
        video_url: The TikTok url to download the video from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        tiktok_schema = self.getTikTokByUrl(video_url, **kwargs)
        download_url = tiktok_schema[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;downloadAddr&#34;]

        return self.getBytes(url=download_url, **kwargs)

    def get_video_no_watermark(self, video_url, return_bytes=1, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Gets the video with no watermark
        .. deprecated::

        Deprecated due to TikTok fixing this

        Parameters
        ----------
        video_url: The url of the video you want to download
        return_bytes: Set this to 0 if you want url, 1 if you want bytes
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        raise Exception(&#34;Deprecated method, TikTok fixed this.&#34;)
        kwargs[&#34;custom_did&#34;] = did

        tiktok_html = self.get_tiktok_by_html(video_url)

        # Thanks to @HasibulKabir for pointing this out on #448
        cleanVideo = (
            &#34;https://api2-16-h2.musical.ly/aweme/v1/play/?video_id={}&amp;line=0&amp;ratio=default&#34;
            &#34;&amp;media_type=4&amp;vr_type=0&#34;
        ).format(tiktok_html[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;id&#34;])

        if return_bytes == 0:
            return cleanVideo

        r = requests.get(
            cleanVideo,
            headers={
                &#34;method&#34;: &#34;GET&#34;,
                &#34;accept-encoding&#34;: &#34;utf-8&#34;,
                &#34;user-agent&#34;: &#34;okhttp&#34;,
            },
            proxies=self.__format_proxy(proxy),
        )

        if r.text[0] == &#34;{&#34;:
            raise TikTokCaptchaError()

        return r.content

    def get_music_title(self, id, **kwargs):
        &#34;&#34;&#34;Retrieves a music title given an ID

        Parameters
        ----------
        id: The music id to get the title for
        &#34;&#34;&#34;
        r = requests.get(
            &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )
        t = r.text
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]

        music_object = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]
        if not music_object.get(&#34;title&#34;, None):
            raise TikTokNotFoundError(&#34;Song of {} id does not exist&#34;.format(str(id)))

        return music_object[&#34;title&#34;]

    def get_secuid(self, username, **kwargs):
        &#34;&#34;&#34;Gets the secUid for a specific username

        Parameters
        ----------
        username: The username to get the secUid for
        &#34;&#34;&#34;
        r = requests.get(
            &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(
                kwargs.get(&#34;proxy&#34;, None), cookies=self.get_cookies(**kwargs)
            ),
        )
        try:
            return r.text.split(&#39;&#34;secUid&#34;:&#34;&#39;)[1].split(&#39;&#34;,&#34;secret&#34;:&#39;)[0]
        except IndexError as e:
            logging.info(r.text)
            logging.error(e)
            raise Exception(
                &#34;Retrieving the user secUid failed. Likely due to TikTok wanting captcha validation. Try to use a proxy.&#34;
            )

    def generate_did(self):
        &#34;&#34;&#34;Generates a valid did for other methods. Pass this as the custom_did field to download videos&#34;&#34;&#34;
        return &#34;&#34;.join(random.choice(string.digits) for num in range(19))

    #
    # PRIVATE METHODS
    #

    def __format_proxy(self, proxy) -&gt; dict:
        &#34;&#34;&#34;
        Formats the proxy object
        &#34;&#34;&#34;
        if proxy is None and self.proxy is not None:
            proxy = self.proxy
        if proxy is not None:
            return {&#34;http&#34;: proxy, &#34;https&#34;: proxy}
        else:
            return None

    def __get_js(self, proxy=None) -&gt; str:
        return requests.get(
            &#34;https://sf16-muse-va.ibytedtos.com/obj/rc-web-sdk-gcs/acrawler.js&#34;,
            proxies=self.__format_proxy(proxy),
        ).text

    def __format_new_params__(self, parm) -&gt; str:
        return parm.replace(&#34;/&#34;, &#34;%2F&#34;).replace(&#34; &#34;, &#34;+&#34;).replace(&#34;;&#34;, &#34;%3B&#34;)

    def __add_new_params__(self) -&gt; str:
        query = {
            &#34;aid&#34;: 1988,
            &#34;app_name&#34;: &#34;tiktok_web&#34;,
            &#34;device_platform&#34;: &#34;web&#34;,
            &#34;referer&#34;: &#34;&#34;,
            &#34;root_referer&#34;: &#34;&#34;,
            &#34;user_agent&#34;: self.__format_new_params__(self.userAgent),
            &#34;cookie_enabled&#34;: &#34;true&#34;,
            &#34;screen_width&#34;: self.width,
            &#34;screen_height&#34;: self.height,
            &#34;browser_language&#34;: self.browser_language,
            &#34;browser_platform&#34;: self.browser_platform,
            &#34;browser_name&#34;: self.browser_name,
            &#34;browser_version&#34;: self.browser_version,
            &#34;browser_online&#34;: &#34;true&#34;,
            &#34;ac&#34;: &#34;4g&#34;,
            &#34;timezone_name&#34;: self.timezone_name,
            &#34;appId&#34;: 1233,
            &#34;appType&#34;: &#34;m&#34;,
            &#34;isAndroid&#34;: False,
            &#34;isMobile&#34;: False,
            &#34;isIOS&#34;: False,
            &#34;OS&#34;: &#34;windows&#34;,
        }
        return urlencode(query)

    # Process the kwargs
    def __process_kwargs__(self, kwargs):
        region = kwargs.get(&#34;region&#34;, &#34;US&#34;)
        language = kwargs.get(&#34;language&#34;, &#34;en&#34;)
        proxy = kwargs.get(&#34;proxy&#34;, None)
        maxCount = kwargs.get(&#34;maxCount&#34;, 35)

        if kwargs.get(&#34;custom_did&#34;, None) != None:
            did = kwargs.get(&#34;custom_did&#34;)
        else:
            if self.custom_did != None:
                did = self.custom_did
            else:
                did = &#34;&#34;.join(random.choice(string.digits) for num in range(19))
        return region, language, proxy, maxCount, did

    #
    # Backwards compatibility of the naming scheme
    #
    getData = get_data
    getBytes = get_bytes
    userPosts = user_posts
    byUsername = by_username
    userPage = user_page
    getUserPager = get_user_pager
    userLiked = user_liked
    userLikedbyUsername = user_liked_by_username
    bySound = by_sound
    getMusicObject = get_music_object
    getMusicObjectFull = get_music_object_full
    byHashtag = by_hashtag
    getHashtagObject = get_hashtag_object
    getRecommendedTikToksByVideoID = get_recommended_tiktoks_by_video_id
    getTikTokById = get_tiktok_by_id
    getTikTokByUrl = get_tiktok_by_url
    discoverHashtags = discover_hashtags
    discoverMusic = discover_music
    getUserObject = get_user_object
    getUser = get_user
    getSuggestedUsersbyID = get_suggested_users_by_id
    getSuggestedUsersbyIDCrawler = get_suggested_users_by_id_crawler
    getSuggestedHashtagsbyID = get_suggested_hashtags_by_id
    getSuggestedHashtagsbyIDCrawler = get_suggested_hashtags_by_id_crawler
    getSuggestedMusicbyID = get_suggested_music_by_id
    getSuggestedMusicIDCrawler = get_suggested_music_id_crawler
    get_Video_By_TikTok = get_video_by_tiktok
    get_Video_By_DownloadURL = get_video_by_download_url
    get_Video_By_Url = get_video_by_url
    get_secUid = get_secuid
    trending = by_trending


# pdoc ignore old naming scheme
__pdoc__ = {
    &#34;TikTokApi.getData&#34;: False,
    &#34;TikTokApi.getBytes&#34;: False,
    &#34;TikTokApi.userPosts&#34;: False,
    &#34;TikTokApi.byUsername&#34;: False,
    &#34;TikTokApi.userPage&#34;: False,
    &#34;TikTokApi.getUserPager&#34;: False,
    &#34;TikTokApi.userLiked&#34;: False,
    &#34;TikTokApi.userLikedbyUsername&#34;: False,
    &#34;TikTokApi.bySound&#34;: False,
    &#34;TikTokApi.getMusicObject&#34;: False,
    &#34;TikTokApi.getMusicObjectFull&#34;: False,
    &#34;TikTokApi.byHashtag&#34;: False,
    &#34;TikTokApi.getHashtagObject&#34;: False,
    &#34;TikTokApi.getRecommendedTikToksByVideoID&#34;: False,
    &#34;TikTokApi.getTikTokById&#34;: False,
    &#34;TikTokApi.getTikTokByUrl&#34;: False,
    &#34;TikTokApi.discoverHashtags&#34;: False,
    &#34;TikTokApi.discoverMusic&#34;: False,
    &#34;TikTokApi.getUserObject&#34;: False,
    &#34;TikTokApi.getUser&#34;: False,
    &#34;TikTokApi.getSuggestedUsersbyID&#34;: False,
    &#34;TikTokApi.getSuggestedUsersbyIDCrawler&#34;: False,
    &#34;TikTokApi.getSuggestedHashtagsbyID&#34;: False,
    &#34;TikTokApi.getSuggestedHashtagsbyIDCrawler&#34;: False,
    &#34;TikTokApi.getSuggestedMusicbyID&#34;: False,
    &#34;TikTokApi.getSuggestedMusicIDCrawler&#34;: False,
    &#34;TikTokApi.get_Video_By_TikTok&#34;: False,
    &#34;TikTokApi.get_Video_By_DownloadURL&#34;: False,
    &#34;TikTokApi.get_Video_By_Url&#34;: False,
    &#34;TikTokApi.get_secUid&#34;: False,
    &#34;TikTokApi.trending&#34;: False,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TikTokApi.tiktok.TikTokApi"><code class="flex name class">
<span>class <span class="ident">TikTokApi</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The TikTokApi class. Used to interact with TikTok, use get_instance NOT this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TikTokApi:
    __instance = None

    def __init__(self, **kwargs):
        &#34;&#34;&#34;The TikTokApi class. Used to interact with TikTok, use get_instance NOT this.&#34;&#34;&#34;
        # Forces Singleton
        if TikTokApi.__instance is None:
            TikTokApi.__instance = self
        else:
            raise Exception(&#34;Only one TikTokApi object is allowed&#34;)
        logging.basicConfig(level=kwargs.get(&#34;logging_level&#34;, logging.WARNING))
        logging.info(&#34;Class initalized&#34;)

        # Some Instance Vars
        self.executablePath = kwargs.get(&#34;executablePath&#34;, None)
        self.custom_did = kwargs.get(&#34;custom_did&#34;, None)
        self.userAgent = (
            &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &#34;
            &#34;AppleWebKit/537.36 (KHTML, like Gecko) &#34;
            &#34;Chrome/86.0.4240.111 Safari/537.36&#34;
        )
        self.proxy = kwargs.get(&#34;proxy&#34;, None)
        self.custom_verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)
        self.signer_url = kwargs.get(&#34;external_signer&#34;, None)
        self.request_delay = kwargs.get(&#34;request_delay&#34;, None)

        if kwargs.get(&#34;use_test_endpoints&#34;, False):
            global BASE_URL
            BASE_URL = &#34;https://t.tiktok.com/&#34;
        if kwargs.get(&#34;use_selenium&#34;, False):
            from .browser_selenium import browser
        else:
            from .browser import browser

        if kwargs.get(&#34;generate_static_did&#34;, False):
            self.custom_did = &#34;&#34;.join(random.choice(string.digits) for num in range(19))

        if self.signer_url is None:
            self.browser = browser(**kwargs)
            self.userAgent = self.browser.userAgent

        try:
            self.timezone_name = self.__format_new_params__(self.browser.timezone_name)
            self.browser_language = self.__format_new_params__(
                self.browser.browser_language
            )
            self.browser_platform = self.__format_new_params__(
                self.browser.browser_platform
            )
            self.browser_name = self.__format_new_params__(self.browser.browser_name)
            self.browser_version = self.__format_new_params__(
                self.browser.browser_version
            )
            self.width = self.browser.width
            self.height = self.browser.height
        except Exception as e:
            logging.error(e)
            logging.warning(
                &#34;An error ocurred while opening your browser but it was ignored.&#34;
            )

            self.timezone_name = &#34;&#34;
            self.browser_language = &#34;&#34;
            self.browser_platform = &#34;&#34;
            self.browser_name = &#34;&#34;
            self.browser_version = &#34;&#34;
            self.width = &#34;1920&#34;
            self.height = &#34;1080&#34;

    @staticmethod
    def get_instance(**kwargs):
        &#34;&#34;&#34;The TikTokApi class. Used to interact with TikTok. This is a singleton
            class to prevent issues from arising with playwright

        Parameters
        ----------
        logging_level: The logging level you want the program to run at, optional
            These are the standard python logging module&#39;s levels.
        request_delay: The amount of time to wait before making a request, optional
            This is used to throttle your own requests as you may end up making too
            many requests to TikTok for your IP.
        custom_did: A TikTok parameter needed to download videos, optional
            The code generates these and handles these pretty well itself, however
            for some things such as video download you will need to set a consistent
            one of these.

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.
        generate_static_did: A parameter that generates a custom_did at the instance level
            Use this if you want to download videos from a script but don&#39;t want to generate
            your own custom_did parameter.
        custom_verifyFp: A TikTok parameter needed to work most of the time, optional
            To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
            I recommend watching the entire thing, as it will help setup this package.

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.

            You can use the following to generate `&#34;&#34;.join(random.choice(string.digits)
            for num in range(19))`
        use_test_endpoints: Send requests to TikTok&#39;s test endpoints, optional
            This parameter when set to true will make requests to TikTok&#39;s testing
            endpoints instead of the live site. I can&#39;t guarantee this will work
            in the future, however currently basically any custom_verifyFp will
            work here which is helpful.
        proxy: A string containing your proxy address, optional
            If you want to do a lot of scraping of TikTok endpoints you&#39;ll likely
            need a proxy.

            Ex: &#34;https://0.0.0.0:8080&#34;

            All the methods take this as a optional parameter, however it&#39;s cleaner code
            to store this at the instance level. You can override this at the specific
            methods.
        use_selenium: Option to use selenium over playwright, optional
            Playwright is selected by default and is the one that I&#39;m designing the
            package to be compatable for, however if playwright doesn&#39;t work on
            your machine feel free to set this to True.
        executablePath: The location of the driver, optional
            This shouldn&#39;t be needed if you&#39;re using playwright
        **kwargs
            Parameters that are passed on to basically every module and methods
            that interact with this main class. These may or may not be documented
            in other places.
        &#34;&#34;&#34;
        if not TikTokApi.__instance:
            TikTokApi(**kwargs)
        return TikTokApi.__instance

    def clean_up(self):
        &#34;&#34;&#34;A basic cleanup method, called automatically from the code&#34;&#34;&#34;
        self.__del__()

    def __del__(self):
        &#34;&#34;&#34;A basic cleanup method, called automatically from the code&#34;&#34;&#34;
        try:
            self.browser.clean_up()
        except Exception:
            pass
        try:
            get_playwright().stop()
        except Exception:
            pass
        TikTokApi.__instance = None

    def external_signer(self, url, custom_did=None, verifyFp=None):
        &#34;&#34;&#34;Makes requests to an external signer instead of using a browser.

        Parameters
        ----------
        url: The server to make requests to
            This server is designed to sign requests. You can find an example
            of this signature server in the examples folder.
        custom_did: A TikTok parameter needed to download videos
            The code generates these and handles these pretty well itself, however
            for some things such as video download you will need to set a consistent
            one of these.
        custom_verifyFp: A TikTok parameter needed to work most of the time,
            To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
            I recommend watching the entire thing, as it will help setup this package.
        &#34;&#34;&#34;
        if custom_did is not None:
            query = {&#34;url&#34;: url, &#34;custom_did&#34;: custom_did, &#34;verifyFp&#34;: verifyFp}
        else:
            query = {&#34;url&#34;: url, &#34;verifyFp&#34;: verifyFp}
        data = requests.get(self.signer_url + &#34;?{}&#34;.format(urlencode(query)))
        parsed_data = data.json()

        return (
            parsed_data[&#34;verifyFp&#34;],
            parsed_data[&#34;did&#34;],
            parsed_data[&#34;_signature&#34;],
            parsed_data[&#34;userAgent&#34;],
            parsed_data[&#34;referrer&#34;],
        )

    def get_data(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Makes requests to TikTok and returns their JSON.

        This is all handled by the package so it&#39;s unlikely
        you will need to use this.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        if self.request_delay is not None:
            time.sleep(self.request_delay)

        if self.proxy is not None:
            proxy = self.proxy

        if kwargs.get(&#34;custom_verifyFp&#34;) == None:
            if self.custom_verifyFp != None:
                verifyFp = self.custom_verifyFp
            else:
                verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
        else:
            verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

        if self.signer_url is None:
            kwargs[&#34;custom_verifyFp&#34;] = verifyFp
            verify_fp, did, signature = self.browser.sign_url(**kwargs)
            userAgent = self.browser.userAgent
            referrer = self.browser.referrer
        else:
            verify_fp, did, signature, userAgent, referrer = self.external_signer(
                kwargs[&#34;url&#34;],
                custom_did=kwargs.get(&#34;custom_did&#34;),
                verifyFp=kwargs.get(&#34;custom_verifyFp&#34;, verifyFp),
            )

        query = {&#34;verifyFp&#34;: verify_fp, &#34;did&#34;: did, &#34;_signature&#34;: signature}
        url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
        r = requests.get(
            url,
            headers={
                &#34;authority&#34;: &#34;m.tiktok.com&#34;,
                &#34;method&#34;: &#34;GET&#34;,
                &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
                &#34;scheme&#34;: &#34;https&#34;,
                &#34;accept&#34;: &#34;application/json, text/plain, */*&#34;,
                &#34;accept-encoding&#34;: &#34;gzip, deflate, br&#34;,
                &#34;accept-language&#34;: &#34;en-US,en;q=0.9&#34;,
                &#34;cache-control&#34;: &#34;no-cache&#34;,
                &#34;dnt&#34;: &#34;1&#34;,
                &#34;origin&#34;: referrer,
                &#34;pragma&#34;: &#34;no-cache&#34;,
                &#34;referer&#34;: referrer,
                &#34;sec-fetch-dest&#34;: &#34;empty&#34;,
                &#34;sec-fetch-mode&#34;: &#34;cors&#34;,
                &#34;sec-fetch-site&#34;: &#34;same-site&#34;,
                &#34;user-agent&#34;: userAgent,
            },
            cookies=self.get_cookies(**kwargs),
            proxies=self.__format_proxy(proxy),
        )
        try:
            json = r.json()
            if json.get(&#34;type&#34;) == &#34;verify&#34;:
                logging.error(
                    &#34;Tiktok wants to display a catcha. Response is:\n&#34; + r.text
                )
                logging.error(self.get_cookies(**kwargs))
                raise TikTokCaptchaError()
            if json.get(&#34;statusCode&#34;, 200) == 10201:
                # Invalid Entity
                raise TikTokNotFoundError(
                    &#34;TikTok returned a response indicating the entity is invalid&#34;
                )
            return r.json()
        except ValueError as e:
            text = r.text
            logging.error(&#34;TikTok response: &#34; + text)
            if len(text) == 0:
                raise EmptyResponseError(
                    &#34;Empty response from Tiktok to &#34; + url
                ) from None
            else:
                logging.error(&#34;Converting response to JSON failed&#34;)
                logging.error(e)
                raise JSONDecodeFailure() from e

    def get_cookies(self, **kwargs):
        &#34;&#34;&#34;Extracts cookies from the kwargs passed to the function for get_data&#34;&#34;&#34;
        did = kwargs.get(
            &#34;custom_did&#34;, &#34;&#34;.join(random.choice(string.digits) for num in range(19))
        )
        if kwargs.get(&#34;custom_verifyFp&#34;) == None:
            if self.custom_verifyFp != None:
                verifyFp = self.custom_verifyFp
            else:
                verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
        else:
            verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

        if kwargs.get(&#34;force_verify_fp_on_cookie_header&#34;, False):
            return {
                &#34;tt_webid&#34;: did,
                &#34;tt_webid_v2&#34;: did,
                &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                    random.choice(string.ascii_uppercase + string.ascii_lowercase)
                    for i in range(16)
                ),
                &#34;s_v_web_id&#34;: verifyFp,
            }
        else:
            return {
                &#34;tt_webid&#34;: did,
                &#34;tt_webid_v2&#34;: did,
                &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                    random.choice(string.ascii_uppercase + string.ascii_lowercase)
                    for i in range(16)
                ),
            }

    def get_bytes(self, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Returns TikTok&#39;s response as bytes, similar to get_data&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        if self.signer_url is None:
            verify_fp, did, signature = self.browser.sign_url(**kwargs)
            userAgent = self.browser.userAgent
            referrer = self.browser.referrer
        else:
            verify_fp, did, signature, userAgent, referrer = self.external_signer(
                kwargs[&#34;url&#34;], custom_did=kwargs.get(&#34;custom_did&#34;, None)
            )
        query = {&#34;verifyFp&#34;: verify_fp, &#34;_signature&#34;: signature}
        url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
        r = requests.get(
            url,
            headers={
                &#34;Accept&#34;: &#34;*/*&#34;,
                &#34;Accept-Encoding&#34;: &#34;identity;q=1, *;q=0&#34;,
                &#34;Accept-Language&#34;: &#34;en-US;en;q=0.9&#34;,
                &#34;Cache-Control&#34;: &#34;no-cache&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: url.split(&#34;/&#34;)[2],
                &#34;Pragma&#34;: &#34;no-cache&#34;,
                &#34;Range&#34;: &#34;bytes=0-&#34;,
                &#34;Referer&#34;: &#34;https://www.tiktok.com/&#34;,
                &#34;User-Agent&#34;: userAgent,
            },
            proxies=self.__format_proxy(proxy),
            cookies=self.get_cookies(**kwargs),
        )
        return r.content

    def by_trending(self, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;
        Gets trending TikToks

        Parameters
        ----------
        count: The amount of TikToks you want returned, optional
            Note: TikTok seems to only support at MOST ~2000 TikToks
            from a single endpoint.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: 1,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;sourceType&#34;: 12,
                &#34;appId&#34;: 1233,
                &#34;itemID&#34;: 1,
                &#34;insertedItemID&#34;: &#34;&#34;,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )
            res = self.getData(url=api_url, **kwargs)
            for t in res.get(&#34;itemList&#34;, []):
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response[:count]

            realCount = count - len(response)

            first = False

        return response[:count]

    def search_for_users(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of users that match the search_term

        Parameters
        ----------
        search_term: The string to search for users by
            This string is the term you want to search for users by.
        count: The number of users to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(search_term, prefix=&#34;user&#34;, count=count, **kwargs)

    def search_for_music(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of music that match the search_term

        Parameters
        ----------
        search_term: The string to search for music by
            This string is the term you want to search for music by.
        count: The number of music to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(search_term, prefix=&#34;music&#34;, count=count, **kwargs)

    def search_for_hashtags(self, search_term, count=28, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of hashtags that match the search_term

        Parameters
        ----------
        search_term: The string to search for music by
            This string is the term you want to search for music by.
        count: The number of music to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        return self.discover_type(
            search_term, prefix=&#34;challenge&#34;, count=count, **kwargs
        )

    def discover_type(self, search_term, prefix, count=28, offset=0, **kwargs) -&gt; list:
        &#34;&#34;&#34;Returns a list of whatever the prefix type you pass in

        Parameters
        ----------
        search_term: The string to search by
            This string is the term you want to search by.
        prefix: The prefix of what to search for
            Valid options are user/music/challenge
        count: The number search results to return
            Note: maximum is around 28 for this type of endpoint.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        while len(response) &lt; count:
            query = {
                &#34;discoverType&#34;: count,
                &#34;needItemList&#34;: False,
                &#34;keyWord&#34;: search_term,
                &#34;offset&#34;: offset,
                &#34;count&#34;: 99,
                &#34;useRecommend&#34;: False,
                &#34;language&#34;: &#34;en&#34;,
            }
            api_url = &#34;{}api/discover/{}/?{}&amp;{}&#34;.format(
                BASE_URL, prefix, self.__add_new_params__(), urlencode(query)
            )
            data = self.getData(url=api_url, **kwargs)

            if &#34;userInfoList&#34; in data.keys():
                for x in data[&#34;userInfoList&#34;]:
                    response.append(x)
            elif &#34;musicInfoList&#34; in data.keys():
                for x in data[&#34;musicInfoList&#34;]:
                    response.append(x)
            elif &#34;challengeInfoList&#34; in data.keys():
                for x in data[&#34;challengeInfoList&#34;]:
                    response.append(x)
            else:
                logging.info(&#34;TikTok is not sending videos beyond this point.&#34;)
                break

            offset += maxCount

        return response[:count]

    def user_posts(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns an array of dictionaries representing TikToks for a user.

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        secUID: The secUID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: userID,
                &#34;cursor&#34;: cursor,
                &#34;type&#34;: 1,
                &#34;secUid&#34;: secUID,
                &#34;sourceType&#34;: 8,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/post/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            if &#34;itemList&#34; in res.keys():
                for t in res[&#34;itemList&#34;]:
                    response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            cursor = res[&#34;cursor&#34;]

            first = False

        return response[:count]

    def by_username(self, username, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks given a user&#39;s username.

        Parameters
        ----------
        username: The username of the TikTok user
            This is just the username of the user you want to
            get videos from.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)
        return self.userPosts(
            data[&#34;id&#34;],
            data[&#34;secUid&#34;],
            count=count,
            **kwargs,
        )

    def user_page(self, userID, secUID, page_size=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing of one page of TikToks given a user&#39;s ID and secUID

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        secUID: The secUID of the user, which TikTok assigns
            You can find this from utilizing other methods or
            just use by_username to find it.
        page_size: The number of posts to return per page
            Gets a specific page of a user, doesn&#39;t iterate.
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        api_url = (
            BASE_URL + &#34;api/post/item_list/?{}&amp;count={}&amp;id={}&amp;type=1&amp;secUid={}&#34;
            &#34;&amp;cursor={}&amp;sourceType=8&amp;appId=1233&amp;region={}&amp;language={}&#34;.format(
                self.__add_new_params__(),
                page_size,
                str(userID),
                str(secUID),
                cursor,
                region,
                language,
            )
        )

        return self.getData(url=api_url, **kwargs)

    def get_user_pager(self, username, page_size=30, cursor=0, **kwargs):
        &#34;&#34;&#34;Returns a generator to page through a user&#39;s feed

        Parameters
        ----------
        username: The username of the user
        page_size: The number of posts to return in a page
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)

        while True:
            resp = self.userPage(
                data[&#34;id&#34;],
                data[&#34;secUid&#34;],
                page_size=page_size,
                cursor=cursor,
                **kwargs,
            )

            try:
                page = resp[&#34;itemList&#34;]
            except KeyError:
                # No mo results
                return

            cursor = resp[&#34;cursor&#34;]

            yield page

            if not resp[&#34;hasMore&#34;]:
                return  # all done

    def user_liked(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks that a given a user has liked.
           Note: The user&#39;s likes must be public

        Parameters
        ----------
        userID: The userID of the user, which TikTok assigns
        secUID: The secUID of the user, which TikTok assigns
        count: The number of posts to return
                      Note: seems to only support up to ~2,000
        cursor: The offset of a page
            The offset to return new videos from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: userID,
                &#34;type&#34;: 2,
                &#34;secUid&#34;: secUID,
                &#34;cursor&#34;: cursor,
                &#34;sourceType&#34;: 9,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/favorite/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            try:
                res[&#34;itemList&#34;]
            except Exception:
                logging.error(&#34;User&#39;s likes are most likely private&#34;)
                return []

            for t in res[&#34;itemList&#34;]:
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            cursor = res[&#34;cursor&#34;]

            first = False

        return response[:count]

    def user_liked_by_username(self, username, count=30, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks a user has liked by username.
           Note: The user&#39;s likes must be public

        Parameters
        ----------
        username: The username of the user
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        data = self.getUserObject(username, **kwargs)
        return self.userLiked(
            data[&#34;id&#34;],
            data[&#34;secUid&#34;],
            count=count,
            **kwargs,
        )

    def by_sound(self, id, count=30, offset=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific sound.

        Parameters
        ----------
        id: The sound id to search by
            Note: Can be found in the URL of the sound specific page or with other methods.
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        response = []

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;secUid&#34;: &#34;&#34;,
                &#34;musicID&#34;: str(id),
                &#34;count&#34;: str(realCount),
                &#34;cursor&#34;: offset,
                &#34;shareUid&#34;: &#34;&#34;,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/music/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            try:
                for t in res[&#34;items&#34;]:
                    response.append(t)
            except KeyError:
                for t in res[&#34;itemList&#34;]:
                    response.append(t)

            if not res[&#34;hasMore&#34;]:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            realCount = count - len(response)
            offset = res[&#34;cursor&#34;]

        return response[:count]

    def get_music_object(self, id, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a music object for a specific sound id.

        Parameters
        ----------
        id: The sound id to get the object for
            This can be found by using other methods.
        &#34;&#34;&#34;
        return self.getMusicObjectFull(id, **kwargs)[&#34;music&#34;]

    def get_music_object_full(self, id, **kwargs):
        &#34;&#34;&#34;Returns a music object for a specific sound id.

        Parameters
        ----------
        id: The sound id to get the object for
            This can be found by using other methods.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        r = requests.get(
            &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )
        t = r.text
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        return json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]

    def by_hashtag(self, hashtag, count=30, offset=0, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific hashtag.

        Parameters
        ----------
        hashtag: The hashtag to search by
            Without the # symbol

            A valid string is &#34;funny&#34;
        count: The number of posts to return
            Note: seems to only support up to ~2,000
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        id = self.getHashtagObject(hashtag)[&#34;challengeInfo&#34;][&#34;challenge&#34;][&#34;id&#34;]
        response = []

        required_count = count

        while len(response) &lt; required_count:
            if count &gt; maxCount:
                count = maxCount
            query = {
                &#34;count&#34;: count,
                &#34;challengeID&#34;: id,
                &#34;type&#34;: 3,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;cursor&#34;: offset,
                &#34;priority_region&#34;: &#34;&#34;,
            }
            api_url = &#34;{}api/challenge/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )
            res = self.getData(url=api_url, **kwargs)

            for t in res[&#34;itemList&#34;]:
                response.append(t)

            if not res[&#34;hasMore&#34;]:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response

            offset += maxCount

        return response[:required_count]

    def get_hashtag_object(self, hashtag, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a hashtag object.

        Parameters
        ----------
        hashtag: The hashtag to search by
            Without the # symbol
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;name&#34;: hashtag, &#34;isName&#34;: True, &#34;lang&#34;: language}
        api_url = &#34;{}node/share/tag/{}?{}&amp;{}&#34;.format(
            BASE_URL, quote(hashtag), self.__add_new_params__(), urlencode(query)
        )
        data = self.getData(url=api_url, **kwargs)
        if data[&#34;challengeInfo&#34;].get(&#34;challenge&#34;) is None:
            raise TikTokNotFoundError(&#34;Challenge {} does not exist&#34;.format(hashtag))
        return data

    def get_recommended_tiktoks_by_video_id(
        self, id, count=30, minCursor=0, maxCursor=0, **kwargs
    ) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary listing reccomended TikToks for a specific TikTok video.


        Parameters
        ----------
        id: The id of the video to get suggestions for
            Can be found using other methods
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        response = []
        first = True

        while len(response) &lt; count:
            if count &lt; maxCount:
                realCount = count
            else:
                realCount = maxCount

            query = {
                &#34;count&#34;: realCount,
                &#34;id&#34;: 1,
                &#34;secUid&#34;: &#34;&#34;,
                &#34;maxCursor&#34;: maxCursor,
                &#34;minCursor&#34;: minCursor,
                &#34;sourceType&#34;: 12,
                &#34;appId&#34;: 1233,
                &#34;region&#34;: region,
                &#34;priority_region&#34;: region,
                &#34;language&#34;: language,
            }
            api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
                BASE_URL, self.__add_new_params__(), urlencode(query)
            )

            res = self.getData(url=api_url, **kwargs)

            for t in res.get(&#34;items&#34;, []):
                response.append(t)

            if not res[&#34;hasMore&#34;] and not first:
                logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
                return response[:count]

            realCount = count - len(response)
            maxCursor = res[&#34;maxCursor&#34;]

            first = False

        return response[:count]

    def get_tiktok_by_id(self, id, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary of a specific TikTok.

        Parameters
        ----------
        id: The id of the TikTok you want to get the object for
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        did = kwargs.get(&#34;custom_did&#34;, None)
        query = {
            &#34;itemId&#34;: id,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/item/detail/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)

    def get_tiktok_by_url(self, url, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary of a TikTok object by url.


        Parameters
        ----------
        url: The TikTok url you want to retrieve
            This currently doesn&#39;t support the shortened TikTok
            url links.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        custom_did = kwargs.get(&#34;custom_did&#34;, None)
        if &#34;@&#34; in url and &#34;/video/&#34; in url:
            post_id = url.split(&#34;/video/&#34;)[1].split(&#34;?&#34;)[0]
        else:
            raise Exception(
                &#34;URL format not supported. Below is an example of a supported url.\n&#34;
                &#34;https://www.tiktok.com/@therock/video/6829267836783971589&#34;
            )

        return self.getTikTokById(
            post_id,
            **kwargs,
        )

    def get_tiktok_by_html(self, url, **kwargs) -&gt; dict:
        &#34;&#34;&#34;This method retrieves a TikTok using the html
        endpoints rather than the API based ones.

        Parameters
        ----------
        url: The url of the TikTok to get
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)

        r = requests.get(
            url,
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )

        t = r.text
        try:
            j_raw = t.split(
                &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
            )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        except IndexError:
            if not t:
                logging.error(&#34;TikTok response is empty&#34;)
            else:
                logging.error(&#34;TikTok response: \n &#34; + t)
            raise TikTokCaptchaError()

        data = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

        if data[&#34;serverCode&#34;] == 404:
            raise TikTokNotFoundError(
                &#34;TikTok with that url doesn&#39;t exist&#34;.format(username)
            )

        return data

    def discover_hashtags(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Discover page, consists challenges (hashtags)&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]

    def discover_music(self, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Discover page, consists of music&#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        return self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]

    def get_user_object(self, username, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Gets a user object (dictionary)

        Parameters
        ----------
        username: The username of the user
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        return self.getUser(username, **kwargs)[&#34;userInfo&#34;][&#34;user&#34;]

    def get_user(self, username, **kwargs) -&gt; dict:
        &#34;&#34;&#34;Gets the full exposed user object

        Parameters
        ----------
        username: The username of the user
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        r = requests.get(
            &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )

        t = r.text

        try:
            j_raw = t.split(
                &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
            )[1].split(&#34;&lt;/script&gt;&#34;)[0]
        except IndexError:
            if not t:
                logging.error(&#34;Tiktok response is empty&#34;)
            else:
                logging.error(&#34;Tiktok response: \n &#34; + t)
            raise TikTokCaptchaError()

        user = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

        if user[&#34;serverCode&#34;] == 404:
            raise TikTokNotFoundError(
                &#34;TikTok user with username {} does not exist&#34;.format(username)
            )

        return user

    def get_suggested_users_by_id(
        self, userId=&#34;6745191554350760966&#34;, count=30, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested users given a different TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        count: The amount of users to return, optional
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][0][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_users_by_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for listing of all user objects it can find.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at, optional
            Optional but uses a static one to start, so you may get more
            unique results with setting your own.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        users = []
        unusedIDS = [startingId]
        while len(users) &lt; count:
            userId = random.choice(unusedIDS)
            newUsers = self.getSuggestedUsersbyID(userId=userId, **kwargs)
            unusedIDS.remove(userId)

            for user in newUsers:
                if user not in users:
                    users.append(user)
                    unusedIDS.append(user[&#34;id&#34;])

        return users[:count]

    def get_suggested_hashtags_by_id(
        self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested hashtags given a TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_hashtags_by_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for as many hashtags as it can find.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        hashtags = []
        ids = self.getSuggestedUsersbyIDCrawler(
            count=count, startingId=startingId, **kwargs
        )
        while len(hashtags) &lt; count and len(ids) != 0:
            userId = random.choice(ids)
            newTags = self.getSuggestedHashtagsbyID(userId=userId[&#34;id&#34;], **kwargs)
            ids.remove(userId)

            for hashtag in newTags:
                if hashtag not in hashtags:
                    hashtags.append(hashtag)

        return hashtags[:count]

    def get_suggested_music_by_id(
        self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Returns suggested music given a TikTok user.

        Parameters
        ----------
        userId: The id of the user to get suggestions for
        count: The amount of users to return
        proxy: The IP address of a proxy to make requests from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        query = {
            &#34;noUser&#34;: 0,
            &#34;pageId&#34;: userId,
            &#34;userId&#34;: userId,
            &#34;userCount&#34;: count,
            &#34;scene&#34;: 15,
        }
        api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = []
        for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]:
            res.append(x[&#34;cardItem&#34;])
        return res[:count]

    def get_suggested_music_id_crawler(
        self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
    ) -&gt; list:
        &#34;&#34;&#34;Crawls for hashtags.

        Parameters
        ----------
        count: The amount of users to crawl for
        startingId: The ID of a TikTok user to start at
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        musics = []
        ids = self.getSuggestedUsersbyIDCrawler(
            count=count, startingId=startingId, **kwargs
        )
        while len(musics) &lt; count and len(ids) != 0:
            userId = random.choice(ids)
            newTags = self.getSuggestedMusicbyID(userId=userId[&#34;id&#34;], **kwargs)
            ids.remove(userId)

            for music in newTags:
                if music not in musics:
                    musics.append(music)

        return musics[:count]

    def get_video_by_tiktok(self, data, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads video from TikTok using a TikTok object.

            You will need to set a custom_did to do this for anything but trending.
            To do this, this is pretty simple you can either generate one yourself or,
            you can pass the generate_static_did=True into the constructor of the
            TikTokApi class.

        Parameters
        ----------
        data: A TikTok object
            A TikTok JSON object from any other method.
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        try:
            api_url = data[&#34;video&#34;][&#34;downloadAddr&#34;]
        except Exception:
            try:
                api_url = data[&#34;itemInfos&#34;][&#34;video&#34;][&#34;urls&#34;][0]
            except Exception:
                api_url = data[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;playAddr&#34;]
        return self.get_Video_By_DownloadURL(api_url, **kwargs)

    def get_video_by_download_url(self, download_url, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads video from TikTok using download url in a TikTok object

        Parameters
        ----------
        download_url: The download url key value in a TikTok object
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did
        return self.getBytes(url=download_url, **kwargs)

    def get_video_by_url(self, video_url, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Downloads a TikTok video by a URL

        Parameters
        ----------
        video_url: The TikTok url to download the video from
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        kwargs[&#34;custom_did&#34;] = did

        tiktok_schema = self.getTikTokByUrl(video_url, **kwargs)
        download_url = tiktok_schema[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;downloadAddr&#34;]

        return self.getBytes(url=download_url, **kwargs)

    def get_video_no_watermark(self, video_url, return_bytes=1, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;Gets the video with no watermark
        .. deprecated::

        Deprecated due to TikTok fixing this

        Parameters
        ----------
        video_url: The url of the video you want to download
        return_bytes: Set this to 0 if you want url, 1 if you want bytes
        &#34;&#34;&#34;
        (
            region,
            language,
            proxy,
            maxCount,
            did,
        ) = self.__process_kwargs__(kwargs)
        raise Exception(&#34;Deprecated method, TikTok fixed this.&#34;)
        kwargs[&#34;custom_did&#34;] = did

        tiktok_html = self.get_tiktok_by_html(video_url)

        # Thanks to @HasibulKabir for pointing this out on #448
        cleanVideo = (
            &#34;https://api2-16-h2.musical.ly/aweme/v1/play/?video_id={}&amp;line=0&amp;ratio=default&#34;
            &#34;&amp;media_type=4&amp;vr_type=0&#34;
        ).format(tiktok_html[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;id&#34;])

        if return_bytes == 0:
            return cleanVideo

        r = requests.get(
            cleanVideo,
            headers={
                &#34;method&#34;: &#34;GET&#34;,
                &#34;accept-encoding&#34;: &#34;utf-8&#34;,
                &#34;user-agent&#34;: &#34;okhttp&#34;,
            },
            proxies=self.__format_proxy(proxy),
        )

        if r.text[0] == &#34;{&#34;:
            raise TikTokCaptchaError()

        return r.content

    def get_music_title(self, id, **kwargs):
        &#34;&#34;&#34;Retrieves a music title given an ID

        Parameters
        ----------
        id: The music id to get the title for
        &#34;&#34;&#34;
        r = requests.get(
            &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
            cookies=self.get_cookies(**kwargs),
        )
        t = r.text
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]

        music_object = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]
        if not music_object.get(&#34;title&#34;, None):
            raise TikTokNotFoundError(&#34;Song of {} id does not exist&#34;.format(str(id)))

        return music_object[&#34;title&#34;]

    def get_secuid(self, username, **kwargs):
        &#34;&#34;&#34;Gets the secUid for a specific username

        Parameters
        ----------
        username: The username to get the secUid for
        &#34;&#34;&#34;
        r = requests.get(
            &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
            headers={
                &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
                &#34;authority&#34;: &#34;www.tiktok.com&#34;,
                &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
                &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
                &#34;Connection&#34;: &#34;keep-alive&#34;,
                &#34;Host&#34;: &#34;www.tiktok.com&#34;,
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
            },
            proxies=self.__format_proxy(
                kwargs.get(&#34;proxy&#34;, None), cookies=self.get_cookies(**kwargs)
            ),
        )
        try:
            return r.text.split(&#39;&#34;secUid&#34;:&#34;&#39;)[1].split(&#39;&#34;,&#34;secret&#34;:&#39;)[0]
        except IndexError as e:
            logging.info(r.text)
            logging.error(e)
            raise Exception(
                &#34;Retrieving the user secUid failed. Likely due to TikTok wanting captcha validation. Try to use a proxy.&#34;
            )

    def generate_did(self):
        &#34;&#34;&#34;Generates a valid did for other methods. Pass this as the custom_did field to download videos&#34;&#34;&#34;
        return &#34;&#34;.join(random.choice(string.digits) for num in range(19))

    #
    # PRIVATE METHODS
    #

    def __format_proxy(self, proxy) -&gt; dict:
        &#34;&#34;&#34;
        Formats the proxy object
        &#34;&#34;&#34;
        if proxy is None and self.proxy is not None:
            proxy = self.proxy
        if proxy is not None:
            return {&#34;http&#34;: proxy, &#34;https&#34;: proxy}
        else:
            return None

    def __get_js(self, proxy=None) -&gt; str:
        return requests.get(
            &#34;https://sf16-muse-va.ibytedtos.com/obj/rc-web-sdk-gcs/acrawler.js&#34;,
            proxies=self.__format_proxy(proxy),
        ).text

    def __format_new_params__(self, parm) -&gt; str:
        return parm.replace(&#34;/&#34;, &#34;%2F&#34;).replace(&#34; &#34;, &#34;+&#34;).replace(&#34;;&#34;, &#34;%3B&#34;)

    def __add_new_params__(self) -&gt; str:
        query = {
            &#34;aid&#34;: 1988,
            &#34;app_name&#34;: &#34;tiktok_web&#34;,
            &#34;device_platform&#34;: &#34;web&#34;,
            &#34;referer&#34;: &#34;&#34;,
            &#34;root_referer&#34;: &#34;&#34;,
            &#34;user_agent&#34;: self.__format_new_params__(self.userAgent),
            &#34;cookie_enabled&#34;: &#34;true&#34;,
            &#34;screen_width&#34;: self.width,
            &#34;screen_height&#34;: self.height,
            &#34;browser_language&#34;: self.browser_language,
            &#34;browser_platform&#34;: self.browser_platform,
            &#34;browser_name&#34;: self.browser_name,
            &#34;browser_version&#34;: self.browser_version,
            &#34;browser_online&#34;: &#34;true&#34;,
            &#34;ac&#34;: &#34;4g&#34;,
            &#34;timezone_name&#34;: self.timezone_name,
            &#34;appId&#34;: 1233,
            &#34;appType&#34;: &#34;m&#34;,
            &#34;isAndroid&#34;: False,
            &#34;isMobile&#34;: False,
            &#34;isIOS&#34;: False,
            &#34;OS&#34;: &#34;windows&#34;,
        }
        return urlencode(query)

    # Process the kwargs
    def __process_kwargs__(self, kwargs):
        region = kwargs.get(&#34;region&#34;, &#34;US&#34;)
        language = kwargs.get(&#34;language&#34;, &#34;en&#34;)
        proxy = kwargs.get(&#34;proxy&#34;, None)
        maxCount = kwargs.get(&#34;maxCount&#34;, 35)

        if kwargs.get(&#34;custom_did&#34;, None) != None:
            did = kwargs.get(&#34;custom_did&#34;)
        else:
            if self.custom_did != None:
                did = self.custom_did
            else:
                did = &#34;&#34;.join(random.choice(string.digits) for num in range(19))
        return region, language, proxy, maxCount, did

    #
    # Backwards compatibility of the naming scheme
    #
    getData = get_data
    getBytes = get_bytes
    userPosts = user_posts
    byUsername = by_username
    userPage = user_page
    getUserPager = get_user_pager
    userLiked = user_liked
    userLikedbyUsername = user_liked_by_username
    bySound = by_sound
    getMusicObject = get_music_object
    getMusicObjectFull = get_music_object_full
    byHashtag = by_hashtag
    getHashtagObject = get_hashtag_object
    getRecommendedTikToksByVideoID = get_recommended_tiktoks_by_video_id
    getTikTokById = get_tiktok_by_id
    getTikTokByUrl = get_tiktok_by_url
    discoverHashtags = discover_hashtags
    discoverMusic = discover_music
    getUserObject = get_user_object
    getUser = get_user
    getSuggestedUsersbyID = get_suggested_users_by_id
    getSuggestedUsersbyIDCrawler = get_suggested_users_by_id_crawler
    getSuggestedHashtagsbyID = get_suggested_hashtags_by_id
    getSuggestedHashtagsbyIDCrawler = get_suggested_hashtags_by_id_crawler
    getSuggestedMusicbyID = get_suggested_music_by_id
    getSuggestedMusicIDCrawler = get_suggested_music_id_crawler
    get_Video_By_TikTok = get_video_by_tiktok
    get_Video_By_DownloadURL = get_video_by_download_url
    get_Video_By_Url = get_video_by_url
    get_secUid = get_secuid
    trending = by_trending</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="TikTokApi.tiktok.TikTokApi.get_instance"><code class="name flex">
<span>def <span class="ident">get_instance</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The TikTokApi class. Used to interact with TikTok. This is a singleton
class to prevent issues from arising with playwright</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_level</code></strong> :&ensp;<code>The logging level you want the program to run at</code>, optional</dt>
<dd>These are the standard python logging module's levels.</dd>
<dt><strong><code>request_delay</code></strong> :&ensp;<code>The amount</code> of <code>time to wait before making a request</code>, optional</dt>
<dd>This is used to throttle your own requests as you may end up making too
many requests to TikTok for your IP.</dd>
<dt><strong><code>custom_did</code></strong> :&ensp;<code>A TikTok parameter needed to download videos</code>, optional</dt>
<dd>
<p>The code generates these and handles these pretty well itself, however
for some things such as video download you will need to set a consistent
one of these.</p>
<p>All the methods take this as a optional parameter, however it's cleaner code
to store this at the instance level. You can override this at the specific
methods.</p>
</dd>
<dt><strong><code>generate_static_did</code></strong> :&ensp;<code>A parameter that generates a custom_did at the instance level</code></dt>
<dd>Use this if you want to download videos from a script but don't want to generate
your own custom_did parameter.</dd>
<dt><strong><code>custom_verifyFp</code></strong> :&ensp;<code>A TikTok parameter needed to work most</code> of <code>the time</code>, optional</dt>
<dd>
<p>To get this parameter look at <a href="https://youtu.be/zwLmLfVI-VQ?t=117">this video</a>
I recommend watching the entire thing, as it will help setup this package.</p>
<p>All the methods take this as a optional parameter, however it's cleaner code
to store this at the instance level. You can override this at the specific
methods.</p>
<p>You can use the following to generate <code>"".join(random.choice(string.digits)
for num in range(19))</code></p>
</dd>
<dt><strong><code>use_test_endpoints</code></strong> :&ensp;<code>Send requests to TikTok's test endpoints</code>, optional</dt>
<dd>This parameter when set to true will make requests to TikTok's testing
endpoints instead of the live site. I can't guarantee this will work
in the future, however currently basically any custom_verifyFp will
work here which is helpful.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>A string containing your proxy address</code>, optional</dt>
<dd>
<p>If you want to do a lot of scraping of TikTok endpoints you'll likely
need a proxy.</p>
<p>Ex: "https://0.0.0.0:8080"</p>
<p>All the methods take this as a optional parameter, however it's cleaner code
to store this at the instance level. You can override this at the specific
methods.</p>
</dd>
<dt><strong><code>use_selenium</code></strong> :&ensp;<code>Option to use selenium over playwright</code>, optional</dt>
<dd>Playwright is selected by default and is the one that I'm designing the
package to be compatable for, however if playwright doesn't work on
your machine feel free to set this to True.</dd>
<dt><strong><code>executablePath</code></strong> :&ensp;<code>The location</code> of <code>the driver</code>, optional</dt>
<dd>This shouldn't be needed if you're using playwright</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Parameters that are passed on to basically every module and methods
that interact with this main class. These may or may not be documented
in other places.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_instance(**kwargs):
    &#34;&#34;&#34;The TikTokApi class. Used to interact with TikTok. This is a singleton
        class to prevent issues from arising with playwright

    Parameters
    ----------
    logging_level: The logging level you want the program to run at, optional
        These are the standard python logging module&#39;s levels.
    request_delay: The amount of time to wait before making a request, optional
        This is used to throttle your own requests as you may end up making too
        many requests to TikTok for your IP.
    custom_did: A TikTok parameter needed to download videos, optional
        The code generates these and handles these pretty well itself, however
        for some things such as video download you will need to set a consistent
        one of these.

        All the methods take this as a optional parameter, however it&#39;s cleaner code
        to store this at the instance level. You can override this at the specific
        methods.
    generate_static_did: A parameter that generates a custom_did at the instance level
        Use this if you want to download videos from a script but don&#39;t want to generate
        your own custom_did parameter.
    custom_verifyFp: A TikTok parameter needed to work most of the time, optional
        To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
        I recommend watching the entire thing, as it will help setup this package.

        All the methods take this as a optional parameter, however it&#39;s cleaner code
        to store this at the instance level. You can override this at the specific
        methods.

        You can use the following to generate `&#34;&#34;.join(random.choice(string.digits)
        for num in range(19))`
    use_test_endpoints: Send requests to TikTok&#39;s test endpoints, optional
        This parameter when set to true will make requests to TikTok&#39;s testing
        endpoints instead of the live site. I can&#39;t guarantee this will work
        in the future, however currently basically any custom_verifyFp will
        work here which is helpful.
    proxy: A string containing your proxy address, optional
        If you want to do a lot of scraping of TikTok endpoints you&#39;ll likely
        need a proxy.

        Ex: &#34;https://0.0.0.0:8080&#34;

        All the methods take this as a optional parameter, however it&#39;s cleaner code
        to store this at the instance level. You can override this at the specific
        methods.
    use_selenium: Option to use selenium over playwright, optional
        Playwright is selected by default and is the one that I&#39;m designing the
        package to be compatable for, however if playwright doesn&#39;t work on
        your machine feel free to set this to True.
    executablePath: The location of the driver, optional
        This shouldn&#39;t be needed if you&#39;re using playwright
    **kwargs
        Parameters that are passed on to basically every module and methods
        that interact with this main class. These may or may not be documented
        in other places.
    &#34;&#34;&#34;
    if not TikTokApi.__instance:
        TikTokApi(**kwargs)
    return TikTokApi.__instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="TikTokApi.tiktok.TikTokApi.by_hashtag"><code class="name flex">
<span>def <span class="ident">by_hashtag</span></span>(<span>self, hashtag, count=30, offset=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing TikToks with a specific hashtag.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hashtag</code></strong> :&ensp;<code>The hashtag to search by</code></dt>
<dd>
<p>Without the # symbol</p>
<p>A valid string is "funny"</p>
</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_hashtag(self, hashtag, count=30, offset=0, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific hashtag.

    Parameters
    ----------
    hashtag: The hashtag to search by
        Without the # symbol

        A valid string is &#34;funny&#34;
    count: The number of posts to return
        Note: seems to only support up to ~2,000
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    id = self.getHashtagObject(hashtag)[&#34;challengeInfo&#34;][&#34;challenge&#34;][&#34;id&#34;]
    response = []

    required_count = count

    while len(response) &lt; required_count:
        if count &gt; maxCount:
            count = maxCount
        query = {
            &#34;count&#34;: count,
            &#34;challengeID&#34;: id,
            &#34;type&#34;: 3,
            &#34;secUid&#34;: &#34;&#34;,
            &#34;cursor&#34;: offset,
            &#34;priority_region&#34;: &#34;&#34;,
        }
        api_url = &#34;{}api/challenge/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )
        res = self.getData(url=api_url, **kwargs)

        for t in res[&#34;itemList&#34;]:
            response.append(t)

        if not res[&#34;hasMore&#34;]:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response

        offset += maxCount

    return response[:required_count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.by_sound"><code class="name flex">
<span>def <span class="ident">by_sound</span></span>(<span>self, id, count=30, offset=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing TikToks with a specific sound.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The sound id to search by</code></dt>
<dd>Note: Can be found in the URL of the sound specific page or with other methods.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_sound(self, id, count=30, offset=0, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing TikToks with a specific sound.

    Parameters
    ----------
    id: The sound id to search by
        Note: Can be found in the URL of the sound specific page or with other methods.
    count: The number of posts to return
        Note: seems to only support up to ~2,000
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    response = []

    while len(response) &lt; count:
        if count &lt; maxCount:
            realCount = count
        else:
            realCount = maxCount

        query = {
            &#34;secUid&#34;: &#34;&#34;,
            &#34;musicID&#34;: str(id),
            &#34;count&#34;: str(realCount),
            &#34;cursor&#34;: offset,
            &#34;shareUid&#34;: &#34;&#34;,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/music/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = self.getData(url=api_url, **kwargs)

        try:
            for t in res[&#34;items&#34;]:
                response.append(t)
        except KeyError:
            for t in res[&#34;itemList&#34;]:
                response.append(t)

        if not res[&#34;hasMore&#34;]:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response

        realCount = count - len(response)
        offset = res[&#34;cursor&#34;]

    return response[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.by_trending"><code class="name flex">
<span>def <span class="ident">by_trending</span></span>(<span>self, count=30, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets trending TikToks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>TikToks you want returned</code>, optional</dt>
<dd>Note: TikTok seems to only support at MOST ~2000 TikToks
from a single endpoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_trending(self, count=30, **kwargs) -&gt; dict:
    &#34;&#34;&#34;
    Gets trending TikToks

    Parameters
    ----------
    count: The amount of TikToks you want returned, optional
        Note: TikTok seems to only support at MOST ~2000 TikToks
        from a single endpoint.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    response = []
    first = True

    while len(response) &lt; count:
        if count &lt; maxCount:
            realCount = count
        else:
            realCount = maxCount

        query = {
            &#34;count&#34;: realCount,
            &#34;id&#34;: 1,
            &#34;secUid&#34;: &#34;&#34;,
            &#34;sourceType&#34;: 12,
            &#34;appId&#34;: 1233,
            &#34;itemID&#34;: 1,
            &#34;insertedItemID&#34;: &#34;&#34;,
            &#34;region&#34;: region,
            &#34;priority_region&#34;: region,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )
        res = self.getData(url=api_url, **kwargs)
        for t in res.get(&#34;itemList&#34;, []):
            response.append(t)

        if not res[&#34;hasMore&#34;] and not first:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response[:count]

        realCount = count - len(response)

        first = False

    return response[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.by_username"><code class="name flex">
<span>def <span class="ident">by_username</span></span>(<span>self, username, count=30, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing TikToks given a user's username.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username</code> of <code>the TikTok user</code></dt>
<dd>This is just the username of the user you want to
get videos from.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_username(self, username, count=30, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing TikToks given a user&#39;s username.

    Parameters
    ----------
    username: The username of the TikTok user
        This is just the username of the user you want to
        get videos from.
    count: The number of posts to return
        Note: seems to only support up to ~2,000
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    data = self.getUserObject(username, **kwargs)
    return self.userPosts(
        data[&#34;id&#34;],
        data[&#34;secUid&#34;],
        count=count,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.clean_up"><code class="name flex">
<span>def <span class="ident">clean_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A basic cleanup method, called automatically from the code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up(self):
    &#34;&#34;&#34;A basic cleanup method, called automatically from the code&#34;&#34;&#34;
    self.__del__()</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.discover_hashtags"><code class="name flex">
<span>def <span class="ident">discover_hashtags</span></span>(<span>self, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Discover page, consists challenges (hashtags)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover_hashtags(self, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Discover page, consists challenges (hashtags)&#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
    api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    return self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.discover_music"><code class="name flex">
<span>def <span class="ident">discover_music</span></span>(<span>self, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Discover page, consists of music</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover_music(self, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Discover page, consists of music&#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {&#34;noUser&#34;: 1, &#34;userCount&#34;: 30, &#34;scene&#34;: 0}
    api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    return self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.discover_type"><code class="name flex">
<span>def <span class="ident">discover_type</span></span>(<span>self, search_term, prefix, count=28, offset=0, **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of whatever the prefix type you pass in</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_term</code></strong> :&ensp;<code>The string to search by</code></dt>
<dd>This string is the term you want to search by.</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>The prefix</code> of <code>what to search for</code></dt>
<dd>Valid options are user/music/challenge</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number search results to return</code></dt>
<dd>Note: maximum is around 28 for this type of endpoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover_type(self, search_term, prefix, count=28, offset=0, **kwargs) -&gt; list:
    &#34;&#34;&#34;Returns a list of whatever the prefix type you pass in

    Parameters
    ----------
    search_term: The string to search by
        This string is the term you want to search by.
    prefix: The prefix of what to search for
        Valid options are user/music/challenge
    count: The number search results to return
        Note: maximum is around 28 for this type of endpoint.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    response = []
    while len(response) &lt; count:
        query = {
            &#34;discoverType&#34;: count,
            &#34;needItemList&#34;: False,
            &#34;keyWord&#34;: search_term,
            &#34;offset&#34;: offset,
            &#34;count&#34;: 99,
            &#34;useRecommend&#34;: False,
            &#34;language&#34;: &#34;en&#34;,
        }
        api_url = &#34;{}api/discover/{}/?{}&amp;{}&#34;.format(
            BASE_URL, prefix, self.__add_new_params__(), urlencode(query)
        )
        data = self.getData(url=api_url, **kwargs)

        if &#34;userInfoList&#34; in data.keys():
            for x in data[&#34;userInfoList&#34;]:
                response.append(x)
        elif &#34;musicInfoList&#34; in data.keys():
            for x in data[&#34;musicInfoList&#34;]:
                response.append(x)
        elif &#34;challengeInfoList&#34; in data.keys():
            for x in data[&#34;challengeInfoList&#34;]:
                response.append(x)
        else:
            logging.info(&#34;TikTok is not sending videos beyond this point.&#34;)
            break

        offset += maxCount

    return response[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.external_signer"><code class="name flex">
<span>def <span class="ident">external_signer</span></span>(<span>self, url, custom_did=None, verifyFp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes requests to an external signer instead of using a browser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>The server to make requests to</code></dt>
<dd>This server is designed to sign requests. You can find an example
of this signature server in the examples folder.</dd>
<dt><strong><code>custom_did</code></strong> :&ensp;<code>A TikTok parameter needed to download videos</code></dt>
<dd>The code generates these and handles these pretty well itself, however
for some things such as video download you will need to set a consistent
one of these.</dd>
<dt><strong><code>custom_verifyFp</code></strong> :&ensp;<code>A TikTok parameter needed to work most</code> of <code>the time,</code></dt>
<dd>To get this parameter look at <a href="https://youtu.be/zwLmLfVI-VQ?t=117">this video</a>
I recommend watching the entire thing, as it will help setup this package.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def external_signer(self, url, custom_did=None, verifyFp=None):
    &#34;&#34;&#34;Makes requests to an external signer instead of using a browser.

    Parameters
    ----------
    url: The server to make requests to
        This server is designed to sign requests. You can find an example
        of this signature server in the examples folder.
    custom_did: A TikTok parameter needed to download videos
        The code generates these and handles these pretty well itself, however
        for some things such as video download you will need to set a consistent
        one of these.
    custom_verifyFp: A TikTok parameter needed to work most of the time,
        To get this parameter look at [this video](https://youtu.be/zwLmLfVI-VQ?t=117)
        I recommend watching the entire thing, as it will help setup this package.
    &#34;&#34;&#34;
    if custom_did is not None:
        query = {&#34;url&#34;: url, &#34;custom_did&#34;: custom_did, &#34;verifyFp&#34;: verifyFp}
    else:
        query = {&#34;url&#34;: url, &#34;verifyFp&#34;: verifyFp}
    data = requests.get(self.signer_url + &#34;?{}&#34;.format(urlencode(query)))
    parsed_data = data.json()

    return (
        parsed_data[&#34;verifyFp&#34;],
        parsed_data[&#34;did&#34;],
        parsed_data[&#34;_signature&#34;],
        parsed_data[&#34;userAgent&#34;],
        parsed_data[&#34;referrer&#34;],
    )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.generate_did"><code class="name flex">
<span>def <span class="ident">generate_did</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a valid did for other methods. Pass this as the custom_did field to download videos</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_did(self):
    &#34;&#34;&#34;Generates a valid did for other methods. Pass this as the custom_did field to download videos&#34;&#34;&#34;
    return &#34;&#34;.join(random.choice(string.digits) for num in range(19))</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_bytes"><code class="name flex">
<span>def <span class="ident">get_bytes</span></span>(<span>self, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns TikTok's response as bytes, similar to get_data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bytes(self, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Returns TikTok&#39;s response as bytes, similar to get_data&#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    if self.signer_url is None:
        verify_fp, did, signature = self.browser.sign_url(**kwargs)
        userAgent = self.browser.userAgent
        referrer = self.browser.referrer
    else:
        verify_fp, did, signature, userAgent, referrer = self.external_signer(
            kwargs[&#34;url&#34;], custom_did=kwargs.get(&#34;custom_did&#34;, None)
        )
    query = {&#34;verifyFp&#34;: verify_fp, &#34;_signature&#34;: signature}
    url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
    r = requests.get(
        url,
        headers={
            &#34;Accept&#34;: &#34;*/*&#34;,
            &#34;Accept-Encoding&#34;: &#34;identity;q=1, *;q=0&#34;,
            &#34;Accept-Language&#34;: &#34;en-US;en;q=0.9&#34;,
            &#34;Cache-Control&#34;: &#34;no-cache&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: url.split(&#34;/&#34;)[2],
            &#34;Pragma&#34;: &#34;no-cache&#34;,
            &#34;Range&#34;: &#34;bytes=0-&#34;,
            &#34;Referer&#34;: &#34;https://www.tiktok.com/&#34;,
            &#34;User-Agent&#34;: userAgent,
        },
        proxies=self.__format_proxy(proxy),
        cookies=self.get_cookies(**kwargs),
    )
    return r.content</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_cookies"><code class="name flex">
<span>def <span class="ident">get_cookies</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts cookies from the kwargs passed to the function for get_data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cookies(self, **kwargs):
    &#34;&#34;&#34;Extracts cookies from the kwargs passed to the function for get_data&#34;&#34;&#34;
    did = kwargs.get(
        &#34;custom_did&#34;, &#34;&#34;.join(random.choice(string.digits) for num in range(19))
    )
    if kwargs.get(&#34;custom_verifyFp&#34;) == None:
        if self.custom_verifyFp != None:
            verifyFp = self.custom_verifyFp
        else:
            verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
    else:
        verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

    if kwargs.get(&#34;force_verify_fp_on_cookie_header&#34;, False):
        return {
            &#34;tt_webid&#34;: did,
            &#34;tt_webid_v2&#34;: did,
            &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                random.choice(string.ascii_uppercase + string.ascii_lowercase)
                for i in range(16)
            ),
            &#34;s_v_web_id&#34;: verifyFp,
        }
    else:
        return {
            &#34;tt_webid&#34;: did,
            &#34;tt_webid_v2&#34;: did,
            &#34;tt_csrf_token&#34;: &#34;&#34;.join(
                random.choice(string.ascii_uppercase + string.ascii_lowercase)
                for i in range(16)
            ),
        }</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Makes requests to TikTok and returns their JSON.</p>
<p>This is all handled by the package so it's unlikely
you will need to use this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Makes requests to TikTok and returns their JSON.

    This is all handled by the package so it&#39;s unlikely
    you will need to use this.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    if self.request_delay is not None:
        time.sleep(self.request_delay)

    if self.proxy is not None:
        proxy = self.proxy

    if kwargs.get(&#34;custom_verifyFp&#34;) == None:
        if self.custom_verifyFp != None:
            verifyFp = self.custom_verifyFp
        else:
            verifyFp = &#34;verify_khr3jabg_V7ucdslq_Vrw9_4KPb_AJ1b_Ks706M8zIJTq&#34;
    else:
        verifyFp = kwargs.get(&#34;custom_verifyFp&#34;)

    if self.signer_url is None:
        kwargs[&#34;custom_verifyFp&#34;] = verifyFp
        verify_fp, did, signature = self.browser.sign_url(**kwargs)
        userAgent = self.browser.userAgent
        referrer = self.browser.referrer
    else:
        verify_fp, did, signature, userAgent, referrer = self.external_signer(
            kwargs[&#34;url&#34;],
            custom_did=kwargs.get(&#34;custom_did&#34;),
            verifyFp=kwargs.get(&#34;custom_verifyFp&#34;, verifyFp),
        )

    query = {&#34;verifyFp&#34;: verify_fp, &#34;did&#34;: did, &#34;_signature&#34;: signature}
    url = &#34;{}&amp;{}&#34;.format(kwargs[&#34;url&#34;], urlencode(query))
    r = requests.get(
        url,
        headers={
            &#34;authority&#34;: &#34;m.tiktok.com&#34;,
            &#34;method&#34;: &#34;GET&#34;,
            &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
            &#34;scheme&#34;: &#34;https&#34;,
            &#34;accept&#34;: &#34;application/json, text/plain, */*&#34;,
            &#34;accept-encoding&#34;: &#34;gzip, deflate, br&#34;,
            &#34;accept-language&#34;: &#34;en-US,en;q=0.9&#34;,
            &#34;cache-control&#34;: &#34;no-cache&#34;,
            &#34;dnt&#34;: &#34;1&#34;,
            &#34;origin&#34;: referrer,
            &#34;pragma&#34;: &#34;no-cache&#34;,
            &#34;referer&#34;: referrer,
            &#34;sec-fetch-dest&#34;: &#34;empty&#34;,
            &#34;sec-fetch-mode&#34;: &#34;cors&#34;,
            &#34;sec-fetch-site&#34;: &#34;same-site&#34;,
            &#34;user-agent&#34;: userAgent,
        },
        cookies=self.get_cookies(**kwargs),
        proxies=self.__format_proxy(proxy),
    )
    try:
        json = r.json()
        if json.get(&#34;type&#34;) == &#34;verify&#34;:
            logging.error(
                &#34;Tiktok wants to display a catcha. Response is:\n&#34; + r.text
            )
            logging.error(self.get_cookies(**kwargs))
            raise TikTokCaptchaError()
        if json.get(&#34;statusCode&#34;, 200) == 10201:
            # Invalid Entity
            raise TikTokNotFoundError(
                &#34;TikTok returned a response indicating the entity is invalid&#34;
            )
        return r.json()
    except ValueError as e:
        text = r.text
        logging.error(&#34;TikTok response: &#34; + text)
        if len(text) == 0:
            raise EmptyResponseError(
                &#34;Empty response from Tiktok to &#34; + url
            ) from None
        else:
            logging.error(&#34;Converting response to JSON failed&#34;)
            logging.error(e)
            raise JSONDecodeFailure() from e</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_hashtag_object"><code class="name flex">
<span>def <span class="ident">get_hashtag_object</span></span>(<span>self, hashtag, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a hashtag object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hashtag</code></strong> :&ensp;<code>The hashtag to search by</code></dt>
<dd>Without the # symbol</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hashtag_object(self, hashtag, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a hashtag object.

    Parameters
    ----------
    hashtag: The hashtag to search by
        Without the # symbol
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {&#34;name&#34;: hashtag, &#34;isName&#34;: True, &#34;lang&#34;: language}
    api_url = &#34;{}node/share/tag/{}?{}&amp;{}&#34;.format(
        BASE_URL, quote(hashtag), self.__add_new_params__(), urlencode(query)
    )
    data = self.getData(url=api_url, **kwargs)
    if data[&#34;challengeInfo&#34;].get(&#34;challenge&#34;) is None:
        raise TikTokNotFoundError(&#34;Challenge {} does not exist&#34;.format(hashtag))
    return data</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_music_object"><code class="name flex">
<span>def <span class="ident">get_music_object</span></span>(<span>self, id, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a music object for a specific sound id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The sound id to get the object for</code></dt>
<dd>This can be found by using other methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_music_object(self, id, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a music object for a specific sound id.

    Parameters
    ----------
    id: The sound id to get the object for
        This can be found by using other methods.
    &#34;&#34;&#34;
    return self.getMusicObjectFull(id, **kwargs)[&#34;music&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_music_object_full"><code class="name flex">
<span>def <span class="ident">get_music_object_full</span></span>(<span>self, id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a music object for a specific sound id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The sound id to get the object for</code></dt>
<dd>This can be found by using other methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_music_object_full(self, id, **kwargs):
    &#34;&#34;&#34;Returns a music object for a specific sound id.

    Parameters
    ----------
    id: The sound id to get the object for
        This can be found by using other methods.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    r = requests.get(
        &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
        headers={
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
            &#34;authority&#34;: &#34;www.tiktok.com&#34;,
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: &#34;www.tiktok.com&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
        },
        proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
        cookies=self.get_cookies(**kwargs),
    )
    t = r.text
    j_raw = t.split(
        &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
    )[1].split(&#34;&lt;/script&gt;&#34;)[0]
    return json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_music_title"><code class="name flex">
<span>def <span class="ident">get_music_title</span></span>(<span>self, id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a music title given an ID</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The music id to get the title for</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_music_title(self, id, **kwargs):
    &#34;&#34;&#34;Retrieves a music title given an ID

    Parameters
    ----------
    id: The music id to get the title for
    &#34;&#34;&#34;
    r = requests.get(
        &#34;https://www.tiktok.com/music/-{}&#34;.format(id),
        headers={
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
            &#34;authority&#34;: &#34;www.tiktok.com&#34;,
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: &#34;www.tiktok.com&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
        },
        proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
        cookies=self.get_cookies(**kwargs),
    )
    t = r.text
    j_raw = t.split(
        &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
    )[1].split(&#34;&lt;/script&gt;&#34;)[0]

    music_object = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;][&#34;musicInfo&#34;]
    if not music_object.get(&#34;title&#34;, None):
        raise TikTokNotFoundError(&#34;Song of {} id does not exist&#34;.format(str(id)))

    return music_object[&#34;title&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_recommended_tiktoks_by_video_id"><code class="name flex">
<span>def <span class="ident">get_recommended_tiktoks_by_video_id</span></span>(<span>self, id, count=30, minCursor=0, maxCursor=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing reccomended TikToks for a specific TikTok video.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The id</code> of <code>the video to get suggestions for</code></dt>
<dd>Can be found using other methods</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recommended_tiktoks_by_video_id(
    self, id, count=30, minCursor=0, maxCursor=0, **kwargs
) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing reccomended TikToks for a specific TikTok video.


    Parameters
    ----------
    id: The id of the video to get suggestions for
        Can be found using other methods
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    response = []
    first = True

    while len(response) &lt; count:
        if count &lt; maxCount:
            realCount = count
        else:
            realCount = maxCount

        query = {
            &#34;count&#34;: realCount,
            &#34;id&#34;: 1,
            &#34;secUid&#34;: &#34;&#34;,
            &#34;maxCursor&#34;: maxCursor,
            &#34;minCursor&#34;: minCursor,
            &#34;sourceType&#34;: 12,
            &#34;appId&#34;: 1233,
            &#34;region&#34;: region,
            &#34;priority_region&#34;: region,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/recommend/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = self.getData(url=api_url, **kwargs)

        for t in res.get(&#34;items&#34;, []):
            response.append(t)

        if not res[&#34;hasMore&#34;] and not first:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response[:count]

        realCount = count - len(response)
        maxCursor = res[&#34;maxCursor&#34;]

        first = False

    return response[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_secuid"><code class="name flex">
<span>def <span class="ident">get_secuid</span></span>(<span>self, username, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the secUid for a specific username</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username to get the secUid for</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_secuid(self, username, **kwargs):
    &#34;&#34;&#34;Gets the secUid for a specific username

    Parameters
    ----------
    username: The username to get the secUid for
    &#34;&#34;&#34;
    r = requests.get(
        &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
        headers={
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
            &#34;authority&#34;: &#34;www.tiktok.com&#34;,
            &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: &#34;www.tiktok.com&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
        },
        proxies=self.__format_proxy(
            kwargs.get(&#34;proxy&#34;, None), cookies=self.get_cookies(**kwargs)
        ),
    )
    try:
        return r.text.split(&#39;&#34;secUid&#34;:&#34;&#39;)[1].split(&#39;&#34;,&#34;secret&#34;:&#39;)[0]
    except IndexError as e:
        logging.info(r.text)
        logging.error(e)
        raise Exception(
            &#34;Retrieving the user secUid failed. Likely due to TikTok wanting captcha validation. Try to use a proxy.&#34;
        )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id"><code class="name flex">
<span>def <span class="ident">get_suggested_hashtags_by_id</span></span>(<span>self, count=30, userId='6745191554350760966', **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggested hashtags given a TikTok user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userId</code></strong> :&ensp;<code>The id</code> of <code>the user to get suggestions for</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_hashtags_by_id(
    self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Returns suggested hashtags given a TikTok user.

    Parameters
    ----------
    userId: The id of the user to get suggestions for
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {
        &#34;noUser&#34;: 0,
        &#34;pageId&#34;: userId,
        &#34;userId&#34;: userId,
        &#34;userCount&#34;: count,
        &#34;scene&#34;: 15,
    }
    api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    res = []
    for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][1][&#34;exploreList&#34;]:
        res.append(x[&#34;cardItem&#34;])
    return res[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id_crawler"><code class="name flex">
<span>def <span class="ident">get_suggested_hashtags_by_id_crawler</span></span>(<span>self, count=30, startingId='6745191554350760966', **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Crawls for as many hashtags as it can find.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>users to crawl for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>startingId</code></strong> :&ensp;<code>The ID</code> of <code>a TikTok user to start at</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_hashtags_by_id_crawler(
    self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Crawls for as many hashtags as it can find.

    Parameters
    ----------
    count: The amount of users to crawl for
    startingId: The ID of a TikTok user to start at
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    hashtags = []
    ids = self.getSuggestedUsersbyIDCrawler(
        count=count, startingId=startingId, **kwargs
    )
    while len(hashtags) &lt; count and len(ids) != 0:
        userId = random.choice(ids)
        newTags = self.getSuggestedHashtagsbyID(userId=userId[&#34;id&#34;], **kwargs)
        ids.remove(userId)

        for hashtag in newTags:
            if hashtag not in hashtags:
                hashtags.append(hashtag)

    return hashtags[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_music_by_id"><code class="name flex">
<span>def <span class="ident">get_suggested_music_by_id</span></span>(<span>self, count=30, userId='6745191554350760966', **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggested music given a TikTok user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userId</code></strong> :&ensp;<code>The id</code> of <code>the user to get suggestions for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>users to return</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>The IP address</code> of <code>a proxy to make requests from</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_music_by_id(
    self, count=30, userId=&#34;6745191554350760966&#34;, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Returns suggested music given a TikTok user.

    Parameters
    ----------
    userId: The id of the user to get suggestions for
    count: The amount of users to return
    proxy: The IP address of a proxy to make requests from
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {
        &#34;noUser&#34;: 0,
        &#34;pageId&#34;: userId,
        &#34;userId&#34;: userId,
        &#34;userCount&#34;: count,
        &#34;scene&#34;: 15,
    }
    api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    res = []
    for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][2][&#34;exploreList&#34;]:
        res.append(x[&#34;cardItem&#34;])
    return res[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_music_id_crawler"><code class="name flex">
<span>def <span class="ident">get_suggested_music_id_crawler</span></span>(<span>self, count=30, startingId='6745191554350760966', **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Crawls for hashtags.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>users to crawl for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>startingId</code></strong> :&ensp;<code>The ID</code> of <code>a TikTok user to start at</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_music_id_crawler(
    self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Crawls for hashtags.

    Parameters
    ----------
    count: The amount of users to crawl for
    startingId: The ID of a TikTok user to start at
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    musics = []
    ids = self.getSuggestedUsersbyIDCrawler(
        count=count, startingId=startingId, **kwargs
    )
    while len(musics) &lt; count and len(ids) != 0:
        userId = random.choice(ids)
        newTags = self.getSuggestedMusicbyID(userId=userId[&#34;id&#34;], **kwargs)
        ids.remove(userId)

        for music in newTags:
            if music not in musics:
                musics.append(music)

    return musics[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id"><code class="name flex">
<span>def <span class="ident">get_suggested_users_by_id</span></span>(<span>self, userId='6745191554350760966', count=30, **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns suggested users given a different TikTok user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userId</code></strong> :&ensp;<code>The id</code> of <code>the user to get suggestions for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>users to return</code>, optional</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_users_by_id(
    self, userId=&#34;6745191554350760966&#34;, count=30, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Returns suggested users given a different TikTok user.

    Parameters
    ----------
    userId: The id of the user to get suggestions for
    count: The amount of users to return, optional
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    query = {
        &#34;noUser&#34;: 0,
        &#34;pageId&#34;: userId,
        &#34;userId&#34;: userId,
        &#34;userCount&#34;: count,
        &#34;scene&#34;: 15,
    }
    api_url = &#34;{}node/share/discover?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    res = []
    for x in self.getData(url=api_url, **kwargs)[&#34;body&#34;][0][&#34;exploreList&#34;]:
        res.append(x[&#34;cardItem&#34;])
    return res[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id_crawler"><code class="name flex">
<span>def <span class="ident">get_suggested_users_by_id_crawler</span></span>(<span>self, count=30, startingId='6745191554350760966', **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Crawls for listing of all user objects it can find.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>The amount</code> of <code>users to crawl for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>startingId</code></strong> :&ensp;<code>The ID</code> of <code>a TikTok user to start at</code>, optional</dt>
<dd>Optional but uses a static one to start, so you may get more
unique results with setting your own.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_users_by_id_crawler(
    self, count=30, startingId=&#34;6745191554350760966&#34;, **kwargs
) -&gt; list:
    &#34;&#34;&#34;Crawls for listing of all user objects it can find.

    Parameters
    ----------
    count: The amount of users to crawl for
    startingId: The ID of a TikTok user to start at, optional
        Optional but uses a static one to start, so you may get more
        unique results with setting your own.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    users = []
    unusedIDS = [startingId]
    while len(users) &lt; count:
        userId = random.choice(unusedIDS)
        newUsers = self.getSuggestedUsersbyID(userId=userId, **kwargs)
        unusedIDS.remove(userId)

        for user in newUsers:
            if user not in users:
                users.append(user)
                unusedIDS.append(user[&#34;id&#34;])

    return users[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_tiktok_by_html"><code class="name flex">
<span>def <span class="ident">get_tiktok_by_html</span></span>(<span>self, url, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves a TikTok using the html
endpoints rather than the API based ones.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>The url</code> of <code>the TikTok to get</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiktok_by_html(self, url, **kwargs) -&gt; dict:
    &#34;&#34;&#34;This method retrieves a TikTok using the html
    endpoints rather than the API based ones.

    Parameters
    ----------
    url: The url of the TikTok to get
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)

    r = requests.get(
        url,
        headers={
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
            &#34;authority&#34;: &#34;www.tiktok.com&#34;,
            &#34;path&#34;: url.split(&#34;tiktok.com&#34;)[1],
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: &#34;www.tiktok.com&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
        },
        proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
        cookies=self.get_cookies(**kwargs),
    )

    t = r.text
    try:
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]
    except IndexError:
        if not t:
            logging.error(&#34;TikTok response is empty&#34;)
        else:
            logging.error(&#34;TikTok response: \n &#34; + t)
        raise TikTokCaptchaError()

    data = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

    if data[&#34;serverCode&#34;] == 404:
        raise TikTokNotFoundError(
            &#34;TikTok with that url doesn&#39;t exist&#34;.format(username)
        )

    return data</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_tiktok_by_id"><code class="name flex">
<span>def <span class="ident">get_tiktok_by_id</span></span>(<span>self, id, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of a specific TikTok.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>The id</code> of <code>the TikTok you want to get the object for</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiktok_by_id(self, id, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary of a specific TikTok.

    Parameters
    ----------
    id: The id of the TikTok you want to get the object for
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    did = kwargs.get(&#34;custom_did&#34;, None)
    query = {
        &#34;itemId&#34;: id,
        &#34;language&#34;: language,
    }
    api_url = &#34;{}api/item/detail/?{}&amp;{}&#34;.format(
        BASE_URL, self.__add_new_params__(), urlencode(query)
    )

    return self.getData(url=api_url, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_tiktok_by_url"><code class="name flex">
<span>def <span class="ident">get_tiktok_by_url</span></span>(<span>self, url, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of a TikTok object by url.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>The TikTok url you want to retrieve</code></dt>
<dd>This currently doesn't support the shortened TikTok
url links.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tiktok_by_url(self, url, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary of a TikTok object by url.


    Parameters
    ----------
    url: The TikTok url you want to retrieve
        This currently doesn&#39;t support the shortened TikTok
        url links.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    custom_did = kwargs.get(&#34;custom_did&#34;, None)
    if &#34;@&#34; in url and &#34;/video/&#34; in url:
        post_id = url.split(&#34;/video/&#34;)[1].split(&#34;?&#34;)[0]
    else:
        raise Exception(
            &#34;URL format not supported. Below is an example of a supported url.\n&#34;
            &#34;https://www.tiktok.com/@therock/video/6829267836783971589&#34;
        )

    return self.getTikTokById(
        post_id,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_user"><code class="name flex">
<span>def <span class="ident">get_user</span></span>(<span>self, username, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the full exposed user object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username</code> of <code>the user</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user(self, username, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Gets the full exposed user object

    Parameters
    ----------
    username: The username of the user
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    r = requests.get(
        &#34;https://tiktok.com/@{}?lang=en&#34;.format(quote(username)),
        headers={
            &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;,
            &#34;authority&#34;: &#34;www.tiktok.com&#34;,
            &#34;path&#34;: &#34;/@{}&#34;.format(quote(username)),
            &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,
            &#34;Connection&#34;: &#34;keep-alive&#34;,
            &#34;Host&#34;: &#34;www.tiktok.com&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#34;,
        },
        proxies=self.__format_proxy(kwargs.get(&#34;proxy&#34;, None)),
        cookies=self.get_cookies(**kwargs),
    )

    t = r.text

    try:
        j_raw = t.split(
            &#39;&lt;script id=&#34;__NEXT_DATA__&#34; type=&#34;application/json&#34; crossorigin=&#34;anonymous&#34;&gt;&#39;
        )[1].split(&#34;&lt;/script&gt;&#34;)[0]
    except IndexError:
        if not t:
            logging.error(&#34;Tiktok response is empty&#34;)
        else:
            logging.error(&#34;Tiktok response: \n &#34; + t)
        raise TikTokCaptchaError()

    user = json.loads(j_raw)[&#34;props&#34;][&#34;pageProps&#34;]

    if user[&#34;serverCode&#34;] == 404:
        raise TikTokNotFoundError(
            &#34;TikTok user with username {} does not exist&#34;.format(username)
        )

    return user</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_user_object"><code class="name flex">
<span>def <span class="ident">get_user_object</span></span>(<span>self, username, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a user object (dictionary)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username</code> of <code>the user</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_object(self, username, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Gets a user object (dictionary)

    Parameters
    ----------
    username: The username of the user
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    return self.getUser(username, **kwargs)[&#34;userInfo&#34;][&#34;user&#34;]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_user_pager"><code class="name flex">
<span>def <span class="ident">get_user_pager</span></span>(<span>self, username, page_size=30, cursor=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator to page through a user's feed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username</code> of <code>the user</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>The number</code> of <code>posts to return in a page</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cursor</code></strong> :&ensp;<code>The offset</code> of <code>a page</code></dt>
<dd>The offset to return new videos from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_pager(self, username, page_size=30, cursor=0, **kwargs):
    &#34;&#34;&#34;Returns a generator to page through a user&#39;s feed

    Parameters
    ----------
    username: The username of the user
    page_size: The number of posts to return in a page
    cursor: The offset of a page
        The offset to return new videos from
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    data = self.getUserObject(username, **kwargs)

    while True:
        resp = self.userPage(
            data[&#34;id&#34;],
            data[&#34;secUid&#34;],
            page_size=page_size,
            cursor=cursor,
            **kwargs,
        )

        try:
            page = resp[&#34;itemList&#34;]
        except KeyError:
            # No mo results
            return

        cursor = resp[&#34;cursor&#34;]

        yield page

        if not resp[&#34;hasMore&#34;]:
            return  # all done</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_video_by_download_url"><code class="name flex">
<span>def <span class="ident">get_video_by_download_url</span></span>(<span>self, download_url, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads video from TikTok using download url in a TikTok object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>download_url</code></strong> :&ensp;<code>The download url key value in a TikTok object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_by_download_url(self, download_url, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Downloads video from TikTok using download url in a TikTok object

    Parameters
    ----------
    download_url: The download url key value in a TikTok object
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    return self.getBytes(url=download_url, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_video_by_tiktok"><code class="name flex">
<span>def <span class="ident">get_video_by_tiktok</span></span>(<span>self, data, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads video from TikTok using a TikTok object.</p>
<pre><code>You will need to set a custom_did to do this for anything but trending.
To do this, this is pretty simple you can either generate one yourself or,
you can pass the generate_static_did=True into the constructor of the
TikTokApi class.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>A TikTok object</code></dt>
<dd>A TikTok JSON object from any other method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_by_tiktok(self, data, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Downloads video from TikTok using a TikTok object.

        You will need to set a custom_did to do this for anything but trending.
        To do this, this is pretty simple you can either generate one yourself or,
        you can pass the generate_static_did=True into the constructor of the
        TikTokApi class.

    Parameters
    ----------
    data: A TikTok object
        A TikTok JSON object from any other method.
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    try:
        api_url = data[&#34;video&#34;][&#34;downloadAddr&#34;]
    except Exception:
        try:
            api_url = data[&#34;itemInfos&#34;][&#34;video&#34;][&#34;urls&#34;][0]
        except Exception:
            api_url = data[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;playAddr&#34;]
    return self.get_Video_By_DownloadURL(api_url, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_video_by_url"><code class="name flex">
<span>def <span class="ident">get_video_by_url</span></span>(<span>self, video_url, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads a TikTok video by a URL</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>video_url</code></strong> :&ensp;<code>The TikTok url to download the video from</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_by_url(self, video_url, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Downloads a TikTok video by a URL

    Parameters
    ----------
    video_url: The TikTok url to download the video from
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    tiktok_schema = self.getTikTokByUrl(video_url, **kwargs)
    download_url = tiktok_schema[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;downloadAddr&#34;]

    return self.getBytes(url=download_url, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.get_video_no_watermark"><code class="name flex">
<span>def <span class="ident">get_video_no_watermark</span></span>(<span>self, video_url, return_bytes=1, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the video with no watermark</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated</p>
</div>
<p>Deprecated due to TikTok fixing this</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>video_url</code></strong> :&ensp;<code>The url</code> of <code>the video you want to download</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>return_bytes</code></strong> :&ensp;<code>Set this to 0 if you want url, 1 if you want bytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_no_watermark(self, video_url, return_bytes=1, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;Gets the video with no watermark
    .. deprecated::

    Deprecated due to TikTok fixing this

    Parameters
    ----------
    video_url: The url of the video you want to download
    return_bytes: Set this to 0 if you want url, 1 if you want bytes
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    raise Exception(&#34;Deprecated method, TikTok fixed this.&#34;)
    kwargs[&#34;custom_did&#34;] = did

    tiktok_html = self.get_tiktok_by_html(video_url)

    # Thanks to @HasibulKabir for pointing this out on #448
    cleanVideo = (
        &#34;https://api2-16-h2.musical.ly/aweme/v1/play/?video_id={}&amp;line=0&amp;ratio=default&#34;
        &#34;&amp;media_type=4&amp;vr_type=0&#34;
    ).format(tiktok_html[&#34;itemInfo&#34;][&#34;itemStruct&#34;][&#34;video&#34;][&#34;id&#34;])

    if return_bytes == 0:
        return cleanVideo

    r = requests.get(
        cleanVideo,
        headers={
            &#34;method&#34;: &#34;GET&#34;,
            &#34;accept-encoding&#34;: &#34;utf-8&#34;,
            &#34;user-agent&#34;: &#34;okhttp&#34;,
        },
        proxies=self.__format_proxy(proxy),
    )

    if r.text[0] == &#34;{&#34;:
        raise TikTokCaptchaError()

    return r.content</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.search_for_hashtags"><code class="name flex">
<span>def <span class="ident">search_for_hashtags</span></span>(<span>self, search_term, count=28, **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of hashtags that match the search_term</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_term</code></strong> :&ensp;<code>The string to search for music by</code></dt>
<dd>This string is the term you want to search for music by.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>music to return</code></dt>
<dd>Note: maximum is around 28 for this type of endpoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_for_hashtags(self, search_term, count=28, **kwargs) -&gt; list:
    &#34;&#34;&#34;Returns a list of hashtags that match the search_term

    Parameters
    ----------
    search_term: The string to search for music by
        This string is the term you want to search for music by.
    count: The number of music to return
        Note: maximum is around 28 for this type of endpoint.
    &#34;&#34;&#34;
    return self.discover_type(
        search_term, prefix=&#34;challenge&#34;, count=count, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.search_for_music"><code class="name flex">
<span>def <span class="ident">search_for_music</span></span>(<span>self, search_term, count=28, **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of music that match the search_term</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_term</code></strong> :&ensp;<code>The string to search for music by</code></dt>
<dd>This string is the term you want to search for music by.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>music to return</code></dt>
<dd>Note: maximum is around 28 for this type of endpoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_for_music(self, search_term, count=28, **kwargs) -&gt; list:
    &#34;&#34;&#34;Returns a list of music that match the search_term

    Parameters
    ----------
    search_term: The string to search for music by
        This string is the term you want to search for music by.
    count: The number of music to return
        Note: maximum is around 28 for this type of endpoint.
    &#34;&#34;&#34;
    return self.discover_type(search_term, prefix=&#34;music&#34;, count=count, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.search_for_users"><code class="name flex">
<span>def <span class="ident">search_for_users</span></span>(<span>self, search_term, count=28, **kwargs) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of users that match the search_term</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>search_term</code></strong> :&ensp;<code>The string to search for users by</code></dt>
<dd>This string is the term you want to search for users by.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>users to return</code></dt>
<dd>Note: maximum is around 28 for this type of endpoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_for_users(self, search_term, count=28, **kwargs) -&gt; list:
    &#34;&#34;&#34;Returns a list of users that match the search_term

    Parameters
    ----------
    search_term: The string to search for users by
        This string is the term you want to search for users by.
    count: The number of users to return
        Note: maximum is around 28 for this type of endpoint.
    &#34;&#34;&#34;
    return self.discover_type(search_term, prefix=&#34;user&#34;, count=count, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.user_liked"><code class="name flex">
<span>def <span class="ident">user_liked</span></span>(<span>self, userID, secUID, count=30, cursor=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing TikToks that a given a user has liked.
Note: The user's likes must be public</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userID</code></strong> :&ensp;<code>The userID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>secUID</code></strong> :&ensp;<code>The secUID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
<dt><strong><code>cursor</code></strong> :&ensp;<code>The offset</code> of <code>a page</code></dt>
<dd>The offset to return new videos from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_liked(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing TikToks that a given a user has liked.
       Note: The user&#39;s likes must be public

    Parameters
    ----------
    userID: The userID of the user, which TikTok assigns
    secUID: The secUID of the user, which TikTok assigns
    count: The number of posts to return
                  Note: seems to only support up to ~2,000
    cursor: The offset of a page
        The offset to return new videos from
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    response = []
    first = True

    while len(response) &lt; count:
        if count &lt; maxCount:
            realCount = count
        else:
            realCount = maxCount

        query = {
            &#34;count&#34;: realCount,
            &#34;id&#34;: userID,
            &#34;type&#34;: 2,
            &#34;secUid&#34;: secUID,
            &#34;cursor&#34;: cursor,
            &#34;sourceType&#34;: 9,
            &#34;appId&#34;: 1233,
            &#34;region&#34;: region,
            &#34;priority_region&#34;: region,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/favorite/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = self.getData(url=api_url, **kwargs)

        try:
            res[&#34;itemList&#34;]
        except Exception:
            logging.error(&#34;User&#39;s likes are most likely private&#34;)
            return []

        for t in res[&#34;itemList&#34;]:
            response.append(t)

        if not res[&#34;hasMore&#34;] and not first:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response

        realCount = count - len(response)
        cursor = res[&#34;cursor&#34;]

        first = False

    return response[:count]</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.user_liked_by_username"><code class="name flex">
<span>def <span class="ident">user_liked_by_username</span></span>(<span>self, username, count=30, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing TikToks a user has liked by username.
Note: The user's likes must be public</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>The username</code> of <code>the user</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_liked_by_username(self, username, count=30, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing TikToks a user has liked by username.
       Note: The user&#39;s likes must be public

    Parameters
    ----------
    username: The username of the user
    count: The number of posts to return
        Note: seems to only support up to ~2,000
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did
    data = self.getUserObject(username, **kwargs)
    return self.userLiked(
        data[&#34;id&#34;],
        data[&#34;secUid&#34;],
        count=count,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.user_page"><code class="name flex">
<span>def <span class="ident">user_page</span></span>(<span>self, userID, secUID, page_size=30, cursor=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary listing of one page of TikToks given a user's ID and secUID</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userID</code></strong> :&ensp;<code>The userID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>You can find this from utilizing other methods or
just use by_username to find it.</dd>
<dt><strong><code>secUID</code></strong> :&ensp;<code>The secUID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>You can find this from utilizing other methods or
just use by_username to find it.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>The number</code> of <code>posts to return per page</code></dt>
<dd>Gets a specific page of a user, doesn't iterate.</dd>
<dt><strong><code>cursor</code></strong> :&ensp;<code>The offset</code> of <code>a page</code></dt>
<dd>The offset to return new videos from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_page(self, userID, secUID, page_size=30, cursor=0, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary listing of one page of TikToks given a user&#39;s ID and secUID

    Parameters
    ----------
    userID: The userID of the user, which TikTok assigns
        You can find this from utilizing other methods or
        just use by_username to find it.
    secUID: The secUID of the user, which TikTok assigns
        You can find this from utilizing other methods or
        just use by_username to find it.
    page_size: The number of posts to return per page
        Gets a specific page of a user, doesn&#39;t iterate.
    cursor: The offset of a page
        The offset to return new videos from
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    api_url = (
        BASE_URL + &#34;api/post/item_list/?{}&amp;count={}&amp;id={}&amp;type=1&amp;secUid={}&#34;
        &#34;&amp;cursor={}&amp;sourceType=8&amp;appId=1233&amp;region={}&amp;language={}&#34;.format(
            self.__add_new_params__(),
            page_size,
            str(userID),
            str(secUID),
            cursor,
            region,
            language,
        )
    )

    return self.getData(url=api_url, **kwargs)</code></pre>
</details>
</dd>
<dt id="TikTokApi.tiktok.TikTokApi.user_posts"><code class="name flex">
<span>def <span class="ident">user_posts</span></span>(<span>self, userID, secUID, count=30, cursor=0, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array of dictionaries representing TikToks for a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userID</code></strong> :&ensp;<code>The userID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>You can find this from utilizing other methods or
just use by_username to find it.</dd>
<dt><strong><code>secUID</code></strong> :&ensp;<code>The secUID</code> of <code>the user, which TikTok assigns</code></dt>
<dd>You can find this from utilizing other methods or
just use by_username to find it.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>The number</code> of <code>posts to return</code></dt>
<dd>Note: seems to only support up to ~2,000</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_posts(self, userID, secUID, count=30, cursor=0, **kwargs) -&gt; dict:
    &#34;&#34;&#34;Returns an array of dictionaries representing TikToks for a user.

    Parameters
    ----------
    userID: The userID of the user, which TikTok assigns
        You can find this from utilizing other methods or
        just use by_username to find it.
    secUID: The secUID of the user, which TikTok assigns
        You can find this from utilizing other methods or
        just use by_username to find it.
    count: The number of posts to return
        Note: seems to only support up to ~2,000
    &#34;&#34;&#34;
    (
        region,
        language,
        proxy,
        maxCount,
        did,
    ) = self.__process_kwargs__(kwargs)
    kwargs[&#34;custom_did&#34;] = did

    response = []
    first = True

    while len(response) &lt; count:
        if count &lt; maxCount:
            realCount = count
        else:
            realCount = maxCount

        query = {
            &#34;count&#34;: realCount,
            &#34;id&#34;: userID,
            &#34;cursor&#34;: cursor,
            &#34;type&#34;: 1,
            &#34;secUid&#34;: secUID,
            &#34;sourceType&#34;: 8,
            &#34;appId&#34;: 1233,
            &#34;region&#34;: region,
            &#34;priority_region&#34;: region,
            &#34;language&#34;: language,
        }
        api_url = &#34;{}api/post/item_list/?{}&amp;{}&#34;.format(
            BASE_URL, self.__add_new_params__(), urlencode(query)
        )

        res = self.getData(url=api_url, **kwargs)

        if &#34;itemList&#34; in res.keys():
            for t in res[&#34;itemList&#34;]:
                response.append(t)

        if not res[&#34;hasMore&#34;] and not first:
            logging.info(&#34;TikTok isn&#39;t sending more TikToks beyond this point.&#34;)
            return response

        realCount = count - len(response)
        cursor = res[&#34;cursor&#34;]

        first = False

    return response[:count]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TikTokApi" href="index.html">TikTokApi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TikTokApi.tiktok.TikTokApi" href="#TikTokApi.tiktok.TikTokApi">TikTokApi</a></code></h4>
<ul class="">
<li><code><a title="TikTokApi.tiktok.TikTokApi.by_hashtag" href="#TikTokApi.tiktok.TikTokApi.by_hashtag">by_hashtag</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.by_sound" href="#TikTokApi.tiktok.TikTokApi.by_sound">by_sound</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.by_trending" href="#TikTokApi.tiktok.TikTokApi.by_trending">by_trending</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.by_username" href="#TikTokApi.tiktok.TikTokApi.by_username">by_username</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.clean_up" href="#TikTokApi.tiktok.TikTokApi.clean_up">clean_up</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.discover_hashtags" href="#TikTokApi.tiktok.TikTokApi.discover_hashtags">discover_hashtags</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.discover_music" href="#TikTokApi.tiktok.TikTokApi.discover_music">discover_music</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.discover_type" href="#TikTokApi.tiktok.TikTokApi.discover_type">discover_type</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.external_signer" href="#TikTokApi.tiktok.TikTokApi.external_signer">external_signer</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.generate_did" href="#TikTokApi.tiktok.TikTokApi.generate_did">generate_did</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_bytes" href="#TikTokApi.tiktok.TikTokApi.get_bytes">get_bytes</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_cookies" href="#TikTokApi.tiktok.TikTokApi.get_cookies">get_cookies</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_data" href="#TikTokApi.tiktok.TikTokApi.get_data">get_data</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_hashtag_object" href="#TikTokApi.tiktok.TikTokApi.get_hashtag_object">get_hashtag_object</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_instance" href="#TikTokApi.tiktok.TikTokApi.get_instance">get_instance</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_music_object" href="#TikTokApi.tiktok.TikTokApi.get_music_object">get_music_object</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_music_object_full" href="#TikTokApi.tiktok.TikTokApi.get_music_object_full">get_music_object_full</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_music_title" href="#TikTokApi.tiktok.TikTokApi.get_music_title">get_music_title</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_recommended_tiktoks_by_video_id" href="#TikTokApi.tiktok.TikTokApi.get_recommended_tiktoks_by_video_id">get_recommended_tiktoks_by_video_id</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_secuid" href="#TikTokApi.tiktok.TikTokApi.get_secuid">get_secuid</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id" href="#TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id">get_suggested_hashtags_by_id</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id_crawler" href="#TikTokApi.tiktok.TikTokApi.get_suggested_hashtags_by_id_crawler">get_suggested_hashtags_by_id_crawler</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_music_by_id" href="#TikTokApi.tiktok.TikTokApi.get_suggested_music_by_id">get_suggested_music_by_id</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_music_id_crawler" href="#TikTokApi.tiktok.TikTokApi.get_suggested_music_id_crawler">get_suggested_music_id_crawler</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id" href="#TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id">get_suggested_users_by_id</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id_crawler" href="#TikTokApi.tiktok.TikTokApi.get_suggested_users_by_id_crawler">get_suggested_users_by_id_crawler</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_tiktok_by_html" href="#TikTokApi.tiktok.TikTokApi.get_tiktok_by_html">get_tiktok_by_html</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_tiktok_by_id" href="#TikTokApi.tiktok.TikTokApi.get_tiktok_by_id">get_tiktok_by_id</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_tiktok_by_url" href="#TikTokApi.tiktok.TikTokApi.get_tiktok_by_url">get_tiktok_by_url</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_user" href="#TikTokApi.tiktok.TikTokApi.get_user">get_user</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_user_object" href="#TikTokApi.tiktok.TikTokApi.get_user_object">get_user_object</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_user_pager" href="#TikTokApi.tiktok.TikTokApi.get_user_pager">get_user_pager</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_video_by_download_url" href="#TikTokApi.tiktok.TikTokApi.get_video_by_download_url">get_video_by_download_url</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_video_by_tiktok" href="#TikTokApi.tiktok.TikTokApi.get_video_by_tiktok">get_video_by_tiktok</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_video_by_url" href="#TikTokApi.tiktok.TikTokApi.get_video_by_url">get_video_by_url</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.get_video_no_watermark" href="#TikTokApi.tiktok.TikTokApi.get_video_no_watermark">get_video_no_watermark</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.search_for_hashtags" href="#TikTokApi.tiktok.TikTokApi.search_for_hashtags">search_for_hashtags</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.search_for_music" href="#TikTokApi.tiktok.TikTokApi.search_for_music">search_for_music</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.search_for_users" href="#TikTokApi.tiktok.TikTokApi.search_for_users">search_for_users</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.user_liked" href="#TikTokApi.tiktok.TikTokApi.user_liked">user_liked</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.user_liked_by_username" href="#TikTokApi.tiktok.TikTokApi.user_liked_by_username">user_liked_by_username</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.user_page" href="#TikTokApi.tiktok.TikTokApi.user_page">user_page</a></code></li>
<li><code><a title="TikTokApi.tiktok.TikTokApi.user_posts" href="#TikTokApi.tiktok.TikTokApi.user_posts">user_posts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>